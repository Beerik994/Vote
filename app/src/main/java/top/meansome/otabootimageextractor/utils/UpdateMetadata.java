// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto
package top.meansome.otabootimageextractor.utils;

public final class UpdateMetadata {
  private UpdateMetadata() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ExtentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:Extent)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return Whether the startBlock field is set.
     */
    boolean hasStartBlock();
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return The startBlock.
     */
    long getStartBlock();

    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return Whether the numBlocks field is set.
     */
    boolean hasNumBlocks();
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return The numBlocks.
     */
    long getNumBlocks();
  }
  /**
   * <pre>
   * Data is packed into blocks on disk, always starting from the beginning
   * of the block. If a file's data is too large for one block, it overflows
   * into another block, which may or may not be the following block on the
   * physical partition. An ordered list of extents is another
   * representation of an ordered list of blocks. For example, a file stored
   * in blocks 9, 10, 11, 2, 18, 12 (in that order) would be stored in
   * extents { {9, 3}, {2, 1}, {18, 1}, {12, 1} } (in that order).
   * In general, files are stored sequentially on disk, so it's more efficient
   * to use extents to encode the block lists (this is effectively
   * run-length encoding).
   * A sentinel value (kuint64max) as the start block denotes a sparse-hole
   * in a file whose block-length is specified by num_blocks.
   * </pre>
   *
   * Protobuf type {@code Extent}
   */
  public static final class Extent extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:Extent)
      ExtentOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Extent.newBuilder() to construct.
    private Extent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Extent() {
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new Extent();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Extent(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              startBlock_ = input.readUInt64();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              numBlocks_ = input.readUInt64();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_Extent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Extent.class, Builder.class);
    }

    private int bitField0_;
    public static final int START_BLOCK_FIELD_NUMBER = 1;
    private long startBlock_;
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return Whether the startBlock field is set.
     */
    @Override
    public boolean hasStartBlock() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return The startBlock.
     */
    @Override
    public long getStartBlock() {
      return startBlock_;
    }

    public static final int NUM_BLOCKS_FIELD_NUMBER = 2;
    private long numBlocks_;
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return Whether the numBlocks field is set.
     */
    @Override
    public boolean hasNumBlocks() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return The numBlocks.
     */
    @Override
    public long getNumBlocks() {
      return numBlocks_;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, startBlock_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, numBlocks_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, startBlock_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, numBlocks_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Extent)) {
        return super.equals(obj);
      }
      Extent other = (Extent) obj;

      if (hasStartBlock() != other.hasStartBlock()) return false;
      if (hasStartBlock()) {
        if (getStartBlock()
            != other.getStartBlock()) return false;
      }
      if (hasNumBlocks() != other.hasNumBlocks()) return false;
      if (hasNumBlocks()) {
        if (getNumBlocks()
            != other.getNumBlocks()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStartBlock()) {
        hash = (37 * hash) + START_BLOCK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStartBlock());
      }
      if (hasNumBlocks()) {
        hash = (37 * hash) + NUM_BLOCKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getNumBlocks());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Extent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Extent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Extent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Extent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Extent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Extent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Extent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Extent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Extent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Extent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Extent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Extent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Extent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Data is packed into blocks on disk, always starting from the beginning
     * of the block. If a file's data is too large for one block, it overflows
     * into another block, which may or may not be the following block on the
     * physical partition. An ordered list of extents is another
     * representation of an ordered list of blocks. For example, a file stored
     * in blocks 9, 10, 11, 2, 18, 12 (in that order) would be stored in
     * extents { {9, 3}, {2, 1}, {18, 1}, {12, 1} } (in that order).
     * In general, files are stored sequentially on disk, so it's more efficient
     * to use extents to encode the block lists (this is effectively
     * run-length encoding).
     * A sentinel value (kuint64max) as the start block denotes a sparse-hole
     * in a file whose block-length is specified by num_blocks.
     * </pre>
     *
     * Protobuf type {@code Extent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:Extent)
        ExtentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Extent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Extent.class, Builder.class);
      }

      // Construct using UpdateMetadata.Extent.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        startBlock_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        numBlocks_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
      }

      @Override
      public Extent getDefaultInstanceForType() {
        return Extent.getDefaultInstance();
      }

      @Override
      public Extent build() {
        Extent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public Extent buildPartial() {
        Extent result = new Extent(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.startBlock_ = startBlock_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.numBlocks_ = numBlocks_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Extent) {
          return mergeFrom((Extent)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Extent other) {
        if (other == Extent.getDefaultInstance()) return this;
        if (other.hasStartBlock()) {
          setStartBlock(other.getStartBlock());
        }
        if (other.hasNumBlocks()) {
          setNumBlocks(other.getNumBlocks());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Extent parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Extent) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long startBlock_ ;
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return Whether the startBlock field is set.
       */
      @Override
      public boolean hasStartBlock() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return The startBlock.
       */
      @Override
      public long getStartBlock() {
        return startBlock_;
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @param value The startBlock to set.
       * @return This builder for chaining.
       */
      public Builder setStartBlock(long value) {
        bitField0_ |= 0x00000001;
        startBlock_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartBlock() {
        bitField0_ = (bitField0_ & ~0x00000001);
        startBlock_ = 0L;
        onChanged();
        return this;
      }

      private long numBlocks_ ;
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return Whether the numBlocks field is set.
       */
      @Override
      public boolean hasNumBlocks() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return The numBlocks.
       */
      @Override
      public long getNumBlocks() {
        return numBlocks_;
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @param value The numBlocks to set.
       * @return This builder for chaining.
       */
      public Builder setNumBlocks(long value) {
        bitField0_ |= 0x00000002;
        numBlocks_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumBlocks() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numBlocks_ = 0L;
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:Extent)
    }

    // @@protoc_insertion_point(class_scope:Extent)
    private static final Extent DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Extent();
    }

    public static Extent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<Extent>
        PARSER = new com.google.protobuf.AbstractParser<Extent>() {
      @Override
      public Extent parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Extent(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Extent> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Extent> getParserForType() {
      return PARSER;
    }

    @Override
    public Extent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignaturesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:Signatures)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    java.util.List<Signatures.Signature>
        getSignaturesList();
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    Signatures.Signature getSignatures(int index);
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    int getSignaturesCount();
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    java.util.List<? extends Signatures.SignatureOrBuilder>
        getSignaturesOrBuilderList();
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    Signatures.SignatureOrBuilder getSignaturesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Signatures: Updates may be signed by the OS vendor. The client verifies
   * an update's signature by hashing the entire download. The section of the
   * download that contains the signature is at the end of the file, so when
   * signing a file, only the part up to the signature part is signed.
   * Then, the client looks inside the download's Signatures message for a
   * Signature message that it knows how to handle. Generally, a client will
   * only know how to handle one type of signature, but an update may contain
   * many signatures to support many different types of client. Then client
   * selects a Signature message and uses that, along with a known public key,
   * to verify the download. The public key is expected to be part of the
   * client.
   * </pre>
   *
   * Protobuf type {@code Signatures}
   */
  public static final class Signatures extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:Signatures)
      SignaturesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Signatures.newBuilder() to construct.
    private Signatures(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Signatures() {
      signatures_ = java.util.Collections.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new Signatures();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Signatures(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                signatures_ = new java.util.ArrayList<Signature>();
                mutable_bitField0_ |= 0x00000001;
              }
              signatures_.add(
                  input.readMessage(Signature.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          signatures_ = java.util.Collections.unmodifiableList(signatures_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Signatures.class, Builder.class);
    }

    public interface SignatureOrBuilder extends
        // @@protoc_insertion_point(interface_extends:Signatures.Signature)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return Whether the version field is set.
       */
      @Deprecated boolean hasVersion();
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return The version.
       */
      @Deprecated int getVersion();

      /**
       * <code>optional bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      boolean hasData();
      /**
       * <code>optional bytes data = 2;</code>
       * @return The data.
       */
      com.google.protobuf.ByteString getData();

      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return Whether the unpaddedSignatureSize field is set.
       */
      boolean hasUnpaddedSignatureSize();
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return The unpaddedSignatureSize.
       */
      int getUnpaddedSignatureSize();
    }
    /**
     * Protobuf type {@code Signatures.Signature}
     */
    public static final class Signature extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:Signatures.Signature)
        SignatureOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Signature.newBuilder() to construct.
      private Signature(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Signature() {
        data_ = com.google.protobuf.ByteString.EMPTY;
      }

      @Override
      @SuppressWarnings({"unused"})
      protected Object newInstance(
          UnusedPrivateParameter unused) {
        return new Signature();
      }

      @Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Signature(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                bitField0_ |= 0x00000001;
                version_ = input.readUInt32();
                break;
              }
              case 18: {
                bitField0_ |= 0x00000002;
                data_ = input.readBytes();
                break;
              }
              case 29: {
                bitField0_ |= 0x00000004;
                unpaddedSignatureSize_ = input.readFixed32();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Signature.class, Builder.class);
      }

      private int bitField0_;
      public static final int VERSION_FIELD_NUMBER = 1;
      private int version_;
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return Whether the version field is set.
       */
      @Override
      @Deprecated public boolean hasVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return The version.
       */
      @Override
      @Deprecated public int getVersion() {
        return version_;
      }

      public static final int DATA_FIELD_NUMBER = 2;
      private com.google.protobuf.ByteString data_;
      /**
       * <code>optional bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      @Override
      public boolean hasData() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bytes data = 2;</code>
       * @return The data.
       */
      @Override
      public com.google.protobuf.ByteString getData() {
        return data_;
      }

      public static final int UNPADDED_SIGNATURE_SIZE_FIELD_NUMBER = 3;
      private int unpaddedSignatureSize_;
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return Whether the unpaddedSignatureSize field is set.
       */
      @Override
      public boolean hasUnpaddedSignatureSize() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return The unpaddedSignatureSize.
       */
      @Override
      public int getUnpaddedSignatureSize() {
        return unpaddedSignatureSize_;
      }

      private byte memoizedIsInitialized = -1;
      @Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt32(1, version_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeBytes(2, data_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeFixed32(3, unpaddedSignatureSize_);
        }
        unknownFields.writeTo(output);
      }

      @Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, version_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBytesSize(2, data_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFixed32Size(3, unpaddedSignatureSize_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @Override
      public boolean equals(final Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Signature)) {
          return super.equals(obj);
        }
        Signature other = (Signature) obj;

        if (hasVersion() != other.hasVersion()) return false;
        if (hasVersion()) {
          if (getVersion()
              != other.getVersion()) return false;
        }
        if (hasData() != other.hasData()) return false;
        if (hasData()) {
          if (!getData()
              .equals(other.getData())) return false;
        }
        if (hasUnpaddedSignatureSize() != other.hasUnpaddedSignatureSize()) return false;
        if (hasUnpaddedSignatureSize()) {
          if (getUnpaddedSignatureSize()
              != other.getUnpaddedSignatureSize()) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasVersion()) {
          hash = (37 * hash) + VERSION_FIELD_NUMBER;
          hash = (53 * hash) + getVersion();
        }
        if (hasData()) {
          hash = (37 * hash) + DATA_FIELD_NUMBER;
          hash = (53 * hash) + getData().hashCode();
        }
        if (hasUnpaddedSignatureSize()) {
          hash = (37 * hash) + UNPADDED_SIGNATURE_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getUnpaddedSignatureSize();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Signature parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Signature parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Signature parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Signature parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Signature parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Signature parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Signature parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static Signature parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static Signature parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static Signature parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Signature parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static Signature parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Signature prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @Override
      protected Builder newBuilderForType(
          BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code Signatures.Signature}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:Signatures.Signature)
          SignatureOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
        }

        @Override
        protected FieldAccessorTable
            internalGetFieldAccessorTable() {
          return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Signature.class, Builder.class);
        }

        // Construct using UpdateMetadata.Signatures.Signature.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @Override
        public Builder clear() {
          super.clear();
          version_ = 0;
          bitField0_ = (bitField0_ & ~0x00000001);
          data_ = com.google.protobuf.ByteString.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          unpaddedSignatureSize_ = 0;
          bitField0_ = (bitField0_ & ~0x00000004);
          return this;
        }

        @Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
        }

        @Override
        public Signature getDefaultInstanceForType() {
          return Signature.getDefaultInstance();
        }

        @Override
        public Signature build() {
          Signature result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @Override
        public Signature buildPartial() {
          Signature result = new Signature(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.version_ = version_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            to_bitField0_ |= 0x00000002;
          }
          result.data_ = data_;
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.unpaddedSignatureSize_ = unpaddedSignatureSize_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @Override
        public Builder clone() {
          return super.clone();
        }
        @Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            Object value) {
          return super.setField(field, value);
        }
        @Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            Object value) {
          return super.addRepeatedField(field, value);
        }
        @Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Signature) {
            return mergeFrom((Signature)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Signature other) {
          if (other == Signature.getDefaultInstance()) return this;
          if (other.hasVersion()) {
            setVersion(other.getVersion());
          }
          if (other.hasData()) {
            setData(other.getData());
          }
          if (other.hasUnpaddedSignatureSize()) {
            setUnpaddedSignatureSize(other.getUnpaddedSignatureSize());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @Override
        public final boolean isInitialized() {
          return true;
        }

        @Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          Signature parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (Signature) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private int version_ ;
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @return Whether the version field is set.
         */
        @Override
        @Deprecated public boolean hasVersion() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @return The version.
         */
        @Override
        @Deprecated public int getVersion() {
          return version_;
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @param value The version to set.
         * @return This builder for chaining.
         */
        @Deprecated public Builder setVersion(int value) {
          bitField0_ |= 0x00000001;
          version_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @return This builder for chaining.
         */
        @Deprecated public Builder clearVersion() {
          bitField0_ = (bitField0_ & ~0x00000001);
          version_ = 0;
          onChanged();
          return this;
        }

        private com.google.protobuf.ByteString data_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <code>optional bytes data = 2;</code>
         * @return Whether the data field is set.
         */
        @Override
        public boolean hasData() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @return The data.
         */
        @Override
        public com.google.protobuf.ByteString getData() {
          return data_;
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @param value The data to set.
         * @return This builder for chaining.
         */
        public Builder setData(com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
          data_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearData() {
          bitField0_ = (bitField0_ & ~0x00000002);
          data_ = getDefaultInstance().getData();
          onChanged();
          return this;
        }

        private int unpaddedSignatureSize_ ;
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return Whether the unpaddedSignatureSize field is set.
         */
        @Override
        public boolean hasUnpaddedSignatureSize() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return The unpaddedSignatureSize.
         */
        @Override
        public int getUnpaddedSignatureSize() {
          return unpaddedSignatureSize_;
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @param value The unpaddedSignatureSize to set.
         * @return This builder for chaining.
         */
        public Builder setUnpaddedSignatureSize(int value) {
          bitField0_ |= 0x00000004;
          unpaddedSignatureSize_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearUnpaddedSignatureSize() {
          bitField0_ = (bitField0_ & ~0x00000004);
          unpaddedSignatureSize_ = 0;
          onChanged();
          return this;
        }
        @Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:Signatures.Signature)
      }

      // @@protoc_insertion_point(class_scope:Signatures.Signature)
      private static final Signature DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Signature();
      }

      public static Signature getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @Deprecated public static final com.google.protobuf.Parser<Signature>
          PARSER = new com.google.protobuf.AbstractParser<Signature>() {
        @Override
        public Signature parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Signature(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Signature> parser() {
        return PARSER;
      }

      @Override
      public com.google.protobuf.Parser<Signature> getParserForType() {
        return PARSER;
      }

      @Override
      public Signature getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int SIGNATURES_FIELD_NUMBER = 1;
    private java.util.List<Signature> signatures_;
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    @Override
    public java.util.List<Signature> getSignaturesList() {
      return signatures_;
    }
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    @Override
    public java.util.List<? extends SignatureOrBuilder>
        getSignaturesOrBuilderList() {
      return signatures_;
    }
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    @Override
    public int getSignaturesCount() {
      return signatures_.size();
    }
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    @Override
    public Signature getSignatures(int index) {
      return signatures_.get(index);
    }
    /**
     * <code>repeated .Signatures.Signature signatures = 1;</code>
     */
    @Override
    public SignatureOrBuilder getSignaturesOrBuilder(
        int index) {
      return signatures_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < signatures_.size(); i++) {
        output.writeMessage(1, signatures_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < signatures_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, signatures_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Signatures)) {
        return super.equals(obj);
      }
      Signatures other = (Signatures) obj;

      if (!getSignaturesList()
          .equals(other.getSignaturesList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getSignaturesCount() > 0) {
        hash = (37 * hash) + SIGNATURES_FIELD_NUMBER;
        hash = (53 * hash) + getSignaturesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Signatures parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Signatures parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Signatures parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Signatures parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Signatures parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Signatures parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Signatures parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Signatures parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Signatures parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Signatures parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Signatures parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Signatures parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Signatures prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Signatures: Updates may be signed by the OS vendor. The client verifies
     * an update's signature by hashing the entire download. The section of the
     * download that contains the signature is at the end of the file, so when
     * signing a file, only the part up to the signature part is signed.
     * Then, the client looks inside the download's Signatures message for a
     * Signature message that it knows how to handle. Generally, a client will
     * only know how to handle one type of signature, but an update may contain
     * many signatures to support many different types of client. Then client
     * selects a Signature message and uses that, along with a known public key,
     * to verify the download. The public key is expected to be part of the
     * client.
     * </pre>
     *
     * Protobuf type {@code Signatures}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:Signatures)
        SignaturesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Signatures.class, Builder.class);
      }

      // Construct using UpdateMetadata.Signatures.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSignaturesFieldBuilder();
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        if (signaturesBuilder_ == null) {
          signatures_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          signaturesBuilder_.clear();
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
      }

      @Override
      public Signatures getDefaultInstanceForType() {
        return Signatures.getDefaultInstance();
      }

      @Override
      public Signatures build() {
        Signatures result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public Signatures buildPartial() {
        Signatures result = new Signatures(this);
        int from_bitField0_ = bitField0_;
        if (signaturesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            signatures_ = java.util.Collections.unmodifiableList(signatures_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.signatures_ = signatures_;
        } else {
          result.signatures_ = signaturesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Signatures) {
          return mergeFrom((Signatures)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Signatures other) {
        if (other == Signatures.getDefaultInstance()) return this;
        if (signaturesBuilder_ == null) {
          if (!other.signatures_.isEmpty()) {
            if (signatures_.isEmpty()) {
              signatures_ = other.signatures_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureSignaturesIsMutable();
              signatures_.addAll(other.signatures_);
            }
            onChanged();
          }
        } else {
          if (!other.signatures_.isEmpty()) {
            if (signaturesBuilder_.isEmpty()) {
              signaturesBuilder_.dispose();
              signaturesBuilder_ = null;
              signatures_ = other.signatures_;
              bitField0_ = (bitField0_ & ~0x00000001);
              signaturesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSignaturesFieldBuilder() : null;
            } else {
              signaturesBuilder_.addAllMessages(other.signatures_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Signatures parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Signatures) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<Signature> signatures_ =
        java.util.Collections.emptyList();
      private void ensureSignaturesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          signatures_ = new java.util.ArrayList<Signature>(signatures_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          Signature, Signature.Builder, SignatureOrBuilder> signaturesBuilder_;

      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<Signature> getSignaturesList() {
        if (signaturesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(signatures_);
        } else {
          return signaturesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public int getSignaturesCount() {
        if (signaturesBuilder_ == null) {
          return signatures_.size();
        } else {
          return signaturesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Signature getSignatures(int index) {
        if (signaturesBuilder_ == null) {
          return signatures_.get(index);
        } else {
          return signaturesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.set(index, value);
          onChanged();
        } else {
          signaturesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.set(index, builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.add(value);
          onChanged();
        } else {
          signaturesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.add(index, value);
          onChanged();
        } else {
          signaturesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.add(builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.add(index, builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder addAllSignatures(
          Iterable<? extends Signature> values) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, signatures_);
          onChanged();
        } else {
          signaturesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder clearSignatures() {
        if (signaturesBuilder_ == null) {
          signatures_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          signaturesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Builder removeSignatures(int index) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.remove(index);
          onChanged();
        } else {
          signaturesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Signature.Builder getSignaturesBuilder(
          int index) {
        return getSignaturesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public SignatureOrBuilder getSignaturesOrBuilder(
          int index) {
        if (signaturesBuilder_ == null) {
          return signatures_.get(index);  } else {
          return signaturesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<? extends SignatureOrBuilder>
           getSignaturesOrBuilderList() {
        if (signaturesBuilder_ != null) {
          return signaturesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(signatures_);
        }
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Signature.Builder addSignaturesBuilder() {
        return getSignaturesFieldBuilder().addBuilder(
            Signature.getDefaultInstance());
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public Signature.Builder addSignaturesBuilder(
          int index) {
        return getSignaturesFieldBuilder().addBuilder(
            index, Signature.getDefaultInstance());
      }
      /**
       * <code>repeated .Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<Signature.Builder>
           getSignaturesBuilderList() {
        return getSignaturesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          Signature, Signature.Builder, SignatureOrBuilder>
          getSignaturesFieldBuilder() {
        if (signaturesBuilder_ == null) {
          signaturesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              Signature, Signature.Builder, SignatureOrBuilder>(
                  signatures_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          signatures_ = null;
        }
        return signaturesBuilder_;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:Signatures)
    }

    // @@protoc_insertion_point(class_scope:Signatures)
    private static final Signatures DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Signatures();
    }

    public static Signatures getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<Signatures>
        PARSER = new com.google.protobuf.AbstractParser<Signatures>() {
      @Override
      public Signatures parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Signatures(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Signatures> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Signatures> getParserForType() {
      return PARSER;
    }

    @Override
    public Signatures getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartitionInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:PartitionInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint64 size = 1;</code>
     * @return Whether the size field is set.
     */
    boolean hasSize();
    /**
     * <code>optional uint64 size = 1;</code>
     * @return The size.
     */
    long getSize();

    /**
     * <code>optional bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    boolean hasHash();
    /**
     * <code>optional bytes hash = 2;</code>
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();
  }
  /**
   * Protobuf type {@code PartitionInfo}
   */
  public static final class PartitionInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:PartitionInfo)
      PartitionInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PartitionInfo.newBuilder() to construct.
    private PartitionInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PartitionInfo() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new PartitionInfo();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PartitionInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              size_ = input.readUInt64();
              break;
            }
            case 18: {
              bitField0_ |= 0x00000002;
              hash_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              PartitionInfo.class, Builder.class);
    }

    private int bitField0_;
    public static final int SIZE_FIELD_NUMBER = 1;
    private long size_;
    /**
     * <code>optional uint64 size = 1;</code>
     * @return Whether the size field is set.
     */
    @Override
    public boolean hasSize() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 size = 1;</code>
     * @return The size.
     */
    @Override
    public long getSize() {
      return size_;
    }

    public static final int HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString hash_;
    /**
     * <code>optional bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    @Override
    public boolean hasHash() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bytes hash = 2;</code>
     * @return The hash.
     */
    @Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, size_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, hash_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, size_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, hash_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof PartitionInfo)) {
        return super.equals(obj);
      }
      PartitionInfo other = (PartitionInfo) obj;

      if (hasSize() != other.hasSize()) return false;
      if (hasSize()) {
        if (getSize()
            != other.getSize()) return false;
      }
      if (hasHash() != other.hasHash()) return false;
      if (hasHash()) {
        if (!getHash()
            .equals(other.getHash())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSize()) {
        hash = (37 * hash) + SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSize());
      }
      if (hasHash()) {
        hash = (37 * hash) + HASH_FIELD_NUMBER;
        hash = (53 * hash) + getHash().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PartitionInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static PartitionInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static PartitionInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static PartitionInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static PartitionInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static PartitionInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static PartitionInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static PartitionInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static PartitionInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static PartitionInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static PartitionInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static PartitionInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(PartitionInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code PartitionInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:PartitionInfo)
        PartitionInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                PartitionInfo.class, Builder.class);
      }

      // Construct using UpdateMetadata.PartitionInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        size_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        hash_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
      }

      @Override
      public PartitionInfo getDefaultInstanceForType() {
        return PartitionInfo.getDefaultInstance();
      }

      @Override
      public PartitionInfo build() {
        PartitionInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PartitionInfo buildPartial() {
        PartitionInfo result = new PartitionInfo(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.size_ = size_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.hash_ = hash_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PartitionInfo) {
          return mergeFrom((PartitionInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PartitionInfo other) {
        if (other == PartitionInfo.getDefaultInstance()) return this;
        if (other.hasSize()) {
          setSize(other.getSize());
        }
        if (other.hasHash()) {
          setHash(other.getHash());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        PartitionInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (PartitionInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long size_ ;
      /**
       * <code>optional uint64 size = 1;</code>
       * @return Whether the size field is set.
       */
      @Override
      public boolean hasSize() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @return The size.
       */
      @Override
      public long getSize() {
        return size_;
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @param value The size to set.
       * @return This builder for chaining.
       */
      public Builder setSize(long value) {
        bitField0_ |= 0x00000001;
        size_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSize() {
        bitField0_ = (bitField0_ & ~0x00000001);
        size_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes hash = 2;</code>
       * @return Whether the hash field is set.
       */
      @Override
      public boolean hasHash() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @return The hash.
       */
      @Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:PartitionInfo)
    }

    // @@protoc_insertion_point(class_scope:PartitionInfo)
    private static final PartitionInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new PartitionInfo();
    }

    public static PartitionInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<PartitionInfo>
        PARSER = new com.google.protobuf.AbstractParser<PartitionInfo>() {
      @Override
      public PartitionInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PartitionInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PartitionInfo> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PartitionInfo> getParserForType() {
      return PARSER;
    }

    @Override
    public PartitionInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ImageInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ImageInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string board = 1 [deprecated = true];</code>
     * @return Whether the board field is set.
     */
    @Deprecated boolean hasBoard();
    /**
     * <code>optional string board = 1 [deprecated = true];</code>
     * @return The board.
     */
    @Deprecated String getBoard();
    /**
     * <code>optional string board = 1 [deprecated = true];</code>
     * @return The bytes for board.
     */
    @Deprecated com.google.protobuf.ByteString
        getBoardBytes();

    /**
     * <code>optional string key = 2 [deprecated = true];</code>
     * @return Whether the key field is set.
     */
    @Deprecated boolean hasKey();
    /**
     * <code>optional string key = 2 [deprecated = true];</code>
     * @return The key.
     */
    @Deprecated String getKey();
    /**
     * <code>optional string key = 2 [deprecated = true];</code>
     * @return The bytes for key.
     */
    @Deprecated com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <code>optional string channel = 3 [deprecated = true];</code>
     * @return Whether the channel field is set.
     */
    @Deprecated boolean hasChannel();
    /**
     * <code>optional string channel = 3 [deprecated = true];</code>
     * @return The channel.
     */
    @Deprecated String getChannel();
    /**
     * <code>optional string channel = 3 [deprecated = true];</code>
     * @return The bytes for channel.
     */
    @Deprecated com.google.protobuf.ByteString
        getChannelBytes();

    /**
     * <code>optional string version = 4 [deprecated = true];</code>
     * @return Whether the version field is set.
     */
    @Deprecated boolean hasVersion();
    /**
     * <code>optional string version = 4 [deprecated = true];</code>
     * @return The version.
     */
    @Deprecated String getVersion();
    /**
     * <code>optional string version = 4 [deprecated = true];</code>
     * @return The bytes for version.
     */
    @Deprecated com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5 [deprecated = true];</code>
     * @return Whether the buildChannel field is set.
     */
    @Deprecated boolean hasBuildChannel();
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5 [deprecated = true];</code>
     * @return The buildChannel.
     */
    @Deprecated String getBuildChannel();
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5 [deprecated = true];</code>
     * @return The bytes for buildChannel.
     */
    @Deprecated com.google.protobuf.ByteString
        getBuildChannelBytes();

    /**
     * <code>optional string build_version = 6 [deprecated = true];</code>
     * @return Whether the buildVersion field is set.
     */
    @Deprecated boolean hasBuildVersion();
    /**
     * <code>optional string build_version = 6 [deprecated = true];</code>
     * @return The buildVersion.
     */
    @Deprecated String getBuildVersion();
    /**
     * <code>optional string build_version = 6 [deprecated = true];</code>
     * @return The bytes for buildVersion.
     */
    @Deprecated com.google.protobuf.ByteString
        getBuildVersionBytes();
  }
  /**
   * <pre>
   * Describe an image we are based on in a human friendly way.
   * Examples:
   *   dev-channel, x86-alex, 1.2.3, mp-v3
   *   nplusone-channel, x86-alex, 1.2.4, mp-v3, dev-channel, 1.2.3
   * All fields will be set, if this message is present.
   * </pre>
   *
   * Protobuf type {@code ImageInfo}
   */
  public static final class ImageInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:ImageInfo)
      ImageInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ImageInfo.newBuilder() to construct.
    private ImageInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ImageInfo() {
      board_ = "";
      key_ = "";
      channel_ = "";
      version_ = "";
      buildChannel_ = "";
      buildVersion_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new ImageInfo();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ImageInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              board_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              key_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              channel_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              version_ = bs;
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000010;
              buildChannel_ = bs;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000020;
              buildVersion_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ImageInfo.class, Builder.class);
    }

    private int bitField0_;
    public static final int BOARD_FIELD_NUMBER = 1;
    private volatile Object board_;
    /**
     * <code>optional string board = 1 [deprecated = true];</code>
     * @return Whether the board field is set.
     */
    @Override
    @Deprecated public boolean hasBoard() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string board = 1 [deprecated = true];</code>
     * @return The board.
     */
    @Override
    @Deprecated public String getBoard() {
      Object ref = board_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          board_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string board = 1 [deprecated = true];</code>
     * @return The bytes for board.
     */
    @Override
    @Deprecated public com.google.protobuf.ByteString
        getBoardBytes() {
      Object ref = board_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        board_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEY_FIELD_NUMBER = 2;
    private volatile Object key_;
    /**
     * <code>optional string key = 2 [deprecated = true];</code>
     * @return Whether the key field is set.
     */
    @Override
    @Deprecated public boolean hasKey() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string key = 2 [deprecated = true];</code>
     * @return The key.
     */
    @Override
    @Deprecated public String getKey() {
      Object ref = key_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string key = 2 [deprecated = true];</code>
     * @return The bytes for key.
     */
    @Override
    @Deprecated public com.google.protobuf.ByteString
        getKeyBytes() {
      Object ref = key_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CHANNEL_FIELD_NUMBER = 3;
    private volatile Object channel_;
    /**
     * <code>optional string channel = 3 [deprecated = true];</code>
     * @return Whether the channel field is set.
     */
    @Override
    @Deprecated public boolean hasChannel() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional string channel = 3 [deprecated = true];</code>
     * @return The channel.
     */
    @Override
    @Deprecated public String getChannel() {
      Object ref = channel_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          channel_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string channel = 3 [deprecated = true];</code>
     * @return The bytes for channel.
     */
    @Override
    @Deprecated public com.google.protobuf.ByteString
        getChannelBytes() {
      Object ref = channel_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        channel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 4;
    private volatile Object version_;
    /**
     * <code>optional string version = 4 [deprecated = true];</code>
     * @return Whether the version field is set.
     */
    @Override
    @Deprecated public boolean hasVersion() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional string version = 4 [deprecated = true];</code>
     * @return The version.
     */
    @Override
    @Deprecated public String getVersion() {
      Object ref = version_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string version = 4 [deprecated = true];</code>
     * @return The bytes for version.
     */
    @Override
    @Deprecated public com.google.protobuf.ByteString
        getVersionBytes() {
      Object ref = version_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BUILD_CHANNEL_FIELD_NUMBER = 5;
    private volatile Object buildChannel_;
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5 [deprecated = true];</code>
     * @return Whether the buildChannel field is set.
     */
    @Override
    @Deprecated public boolean hasBuildChannel() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5 [deprecated = true];</code>
     * @return The buildChannel.
     */
    @Override
    @Deprecated public String getBuildChannel() {
      Object ref = buildChannel_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          buildChannel_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5 [deprecated = true];</code>
     * @return The bytes for buildChannel.
     */
    @Override
    @Deprecated public com.google.protobuf.ByteString
        getBuildChannelBytes() {
      Object ref = buildChannel_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        buildChannel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BUILD_VERSION_FIELD_NUMBER = 6;
    private volatile Object buildVersion_;
    /**
     * <code>optional string build_version = 6 [deprecated = true];</code>
     * @return Whether the buildVersion field is set.
     */
    @Override
    @Deprecated public boolean hasBuildVersion() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional string build_version = 6 [deprecated = true];</code>
     * @return The buildVersion.
     */
    @Override
    @Deprecated public String getBuildVersion() {
      Object ref = buildVersion_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          buildVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string build_version = 6 [deprecated = true];</code>
     * @return The bytes for buildVersion.
     */
    @Override
    @Deprecated public com.google.protobuf.ByteString
        getBuildVersionBytes() {
      Object ref = buildVersion_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        buildVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, board_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, key_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, channel_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, version_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, buildChannel_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, buildVersion_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, board_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, key_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, channel_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, version_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, buildChannel_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, buildVersion_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ImageInfo)) {
        return super.equals(obj);
      }
      ImageInfo other = (ImageInfo) obj;

      if (hasBoard() != other.hasBoard()) return false;
      if (hasBoard()) {
        if (!getBoard()
            .equals(other.getBoard())) return false;
      }
      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasChannel() != other.hasChannel()) return false;
      if (hasChannel()) {
        if (!getChannel()
            .equals(other.getChannel())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (hasBuildChannel() != other.hasBuildChannel()) return false;
      if (hasBuildChannel()) {
        if (!getBuildChannel()
            .equals(other.getBuildChannel())) return false;
      }
      if (hasBuildVersion() != other.hasBuildVersion()) return false;
      if (hasBuildVersion()) {
        if (!getBuildVersion()
            .equals(other.getBuildVersion())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasBoard()) {
        hash = (37 * hash) + BOARD_FIELD_NUMBER;
        hash = (53 * hash) + getBoard().hashCode();
      }
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasChannel()) {
        hash = (37 * hash) + CHANNEL_FIELD_NUMBER;
        hash = (53 * hash) + getChannel().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      if (hasBuildChannel()) {
        hash = (37 * hash) + BUILD_CHANNEL_FIELD_NUMBER;
        hash = (53 * hash) + getBuildChannel().hashCode();
      }
      if (hasBuildVersion()) {
        hash = (37 * hash) + BUILD_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getBuildVersion().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ImageInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ImageInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ImageInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ImageInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ImageInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ImageInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ImageInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ImageInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static ImageInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static ImageInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ImageInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ImageInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ImageInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describe an image we are based on in a human friendly way.
     * Examples:
     *   dev-channel, x86-alex, 1.2.3, mp-v3
     *   nplusone-channel, x86-alex, 1.2.4, mp-v3, dev-channel, 1.2.3
     * All fields will be set, if this message is present.
     * </pre>
     *
     * Protobuf type {@code ImageInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ImageInfo)
        ImageInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ImageInfo.class, Builder.class);
      }

      // Construct using UpdateMetadata.ImageInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        board_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        channel_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        version_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        buildChannel_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        buildVersion_ = "";
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_descriptor;
      }

      @Override
      public ImageInfo getDefaultInstanceForType() {
        return ImageInfo.getDefaultInstance();
      }

      @Override
      public ImageInfo build() {
        ImageInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ImageInfo buildPartial() {
        ImageInfo result = new ImageInfo(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.board_ = board_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.key_ = key_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.channel_ = channel_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.version_ = version_;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          to_bitField0_ |= 0x00000010;
        }
        result.buildChannel_ = buildChannel_;
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.buildVersion_ = buildVersion_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ImageInfo) {
          return mergeFrom((ImageInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ImageInfo other) {
        if (other == ImageInfo.getDefaultInstance()) return this;
        if (other.hasBoard()) {
          bitField0_ |= 0x00000001;
          board_ = other.board_;
          onChanged();
        }
        if (other.hasKey()) {
          bitField0_ |= 0x00000002;
          key_ = other.key_;
          onChanged();
        }
        if (other.hasChannel()) {
          bitField0_ |= 0x00000004;
          channel_ = other.channel_;
          onChanged();
        }
        if (other.hasVersion()) {
          bitField0_ |= 0x00000008;
          version_ = other.version_;
          onChanged();
        }
        if (other.hasBuildChannel()) {
          bitField0_ |= 0x00000010;
          buildChannel_ = other.buildChannel_;
          onChanged();
        }
        if (other.hasBuildVersion()) {
          bitField0_ |= 0x00000020;
          buildVersion_ = other.buildVersion_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        ImageInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (ImageInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object board_ = "";
      /**
       * <code>optional string board = 1 [deprecated = true];</code>
       * @return Whether the board field is set.
       */
      @Deprecated public boolean hasBoard() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string board = 1 [deprecated = true];</code>
       * @return The board.
       */
      @Deprecated public String getBoard() {
        Object ref = board_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            board_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string board = 1 [deprecated = true];</code>
       * @return The bytes for board.
       */
      @Deprecated public com.google.protobuf.ByteString
          getBoardBytes() {
        Object ref = board_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          board_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string board = 1 [deprecated = true];</code>
       * @param value The board to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setBoard(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        board_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string board = 1 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @Deprecated public Builder clearBoard() {
        bitField0_ = (bitField0_ & ~0x00000001);
        board_ = getDefaultInstance().getBoard();
        onChanged();
        return this;
      }
      /**
       * <code>optional string board = 1 [deprecated = true];</code>
       * @param value The bytes for board to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setBoardBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        board_ = value;
        onChanged();
        return this;
      }

      private Object key_ = "";
      /**
       * <code>optional string key = 2 [deprecated = true];</code>
       * @return Whether the key field is set.
       */
      @Deprecated public boolean hasKey() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string key = 2 [deprecated = true];</code>
       * @return The key.
       */
      @Deprecated public String getKey() {
        Object ref = key_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string key = 2 [deprecated = true];</code>
       * @return The bytes for key.
       */
      @Deprecated public com.google.protobuf.ByteString
          getKeyBytes() {
        Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string key = 2 [deprecated = true];</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setKey(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        key_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 2 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @Deprecated public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 2 [deprecated = true];</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        key_ = value;
        onChanged();
        return this;
      }

      private Object channel_ = "";
      /**
       * <code>optional string channel = 3 [deprecated = true];</code>
       * @return Whether the channel field is set.
       */
      @Deprecated public boolean hasChannel() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional string channel = 3 [deprecated = true];</code>
       * @return The channel.
       */
      @Deprecated public String getChannel() {
        Object ref = channel_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            channel_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string channel = 3 [deprecated = true];</code>
       * @return The bytes for channel.
       */
      @Deprecated public com.google.protobuf.ByteString
          getChannelBytes() {
        Object ref = channel_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          channel_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string channel = 3 [deprecated = true];</code>
       * @param value The channel to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setChannel(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        channel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string channel = 3 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @Deprecated public Builder clearChannel() {
        bitField0_ = (bitField0_ & ~0x00000004);
        channel_ = getDefaultInstance().getChannel();
        onChanged();
        return this;
      }
      /**
       * <code>optional string channel = 3 [deprecated = true];</code>
       * @param value The bytes for channel to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setChannelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        channel_ = value;
        onChanged();
        return this;
      }

      private Object version_ = "";
      /**
       * <code>optional string version = 4 [deprecated = true];</code>
       * @return Whether the version field is set.
       */
      @Deprecated public boolean hasVersion() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional string version = 4 [deprecated = true];</code>
       * @return The version.
       */
      @Deprecated public String getVersion() {
        Object ref = version_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string version = 4 [deprecated = true];</code>
       * @return The bytes for version.
       */
      @Deprecated public com.google.protobuf.ByteString
          getVersionBytes() {
        Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string version = 4 [deprecated = true];</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setVersion(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        version_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 4 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @Deprecated public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000008);
        version_ = getDefaultInstance().getVersion();
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 4 [deprecated = true];</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        version_ = value;
        onChanged();
        return this;
      }

      private Object buildChannel_ = "";
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5 [deprecated = true];</code>
       * @return Whether the buildChannel field is set.
       */
      @Deprecated public boolean hasBuildChannel() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5 [deprecated = true];</code>
       * @return The buildChannel.
       */
      @Deprecated public String getBuildChannel() {
        Object ref = buildChannel_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            buildChannel_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5 [deprecated = true];</code>
       * @return The bytes for buildChannel.
       */
      @Deprecated public com.google.protobuf.ByteString
          getBuildChannelBytes() {
        Object ref = buildChannel_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          buildChannel_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5 [deprecated = true];</code>
       * @param value The buildChannel to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setBuildChannel(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        buildChannel_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @Deprecated public Builder clearBuildChannel() {
        bitField0_ = (bitField0_ & ~0x00000010);
        buildChannel_ = getDefaultInstance().getBuildChannel();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5 [deprecated = true];</code>
       * @param value The bytes for buildChannel to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setBuildChannelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        buildChannel_ = value;
        onChanged();
        return this;
      }

      private Object buildVersion_ = "";
      /**
       * <code>optional string build_version = 6 [deprecated = true];</code>
       * @return Whether the buildVersion field is set.
       */
      @Deprecated public boolean hasBuildVersion() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional string build_version = 6 [deprecated = true];</code>
       * @return The buildVersion.
       */
      @Deprecated public String getBuildVersion() {
        Object ref = buildVersion_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            buildVersion_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string build_version = 6 [deprecated = true];</code>
       * @return The bytes for buildVersion.
       */
      @Deprecated public com.google.protobuf.ByteString
          getBuildVersionBytes() {
        Object ref = buildVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          buildVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string build_version = 6 [deprecated = true];</code>
       * @param value The buildVersion to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setBuildVersion(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        buildVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string build_version = 6 [deprecated = true];</code>
       * @return This builder for chaining.
       */
      @Deprecated public Builder clearBuildVersion() {
        bitField0_ = (bitField0_ & ~0x00000020);
        buildVersion_ = getDefaultInstance().getBuildVersion();
        onChanged();
        return this;
      }
      /**
       * <code>optional string build_version = 6 [deprecated = true];</code>
       * @param value The bytes for buildVersion to set.
       * @return This builder for chaining.
       */
      @Deprecated public Builder setBuildVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        buildVersion_ = value;
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:ImageInfo)
    }

    // @@protoc_insertion_point(class_scope:ImageInfo)
    private static final ImageInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ImageInfo();
    }

    public static ImageInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<ImageInfo>
        PARSER = new com.google.protobuf.AbstractParser<ImageInfo>() {
      @Override
      public ImageInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ImageInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ImageInfo> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ImageInfo> getParserForType() {
      return PARSER;
    }

    @Override
    public ImageInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InstallOperationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:InstallOperation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .InstallOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .InstallOperation.Type type = 1;</code>
     * @return The type.
     */
    InstallOperation.Type getType();

    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return Whether the dataOffset field is set.
     */
    boolean hasDataOffset();
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return The dataOffset.
     */
    long getDataOffset();

    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return Whether the dataLength field is set.
     */
    boolean hasDataLength();
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return The dataLength.
     */
    long getDataLength();

    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    java.util.List<Extent>
        getSrcExtentsList();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    Extent getSrcExtents(int index);
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    int getSrcExtentsCount();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    java.util.List<? extends ExtentOrBuilder>
        getSrcExtentsOrBuilderList();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    ExtentOrBuilder getSrcExtentsOrBuilder(
        int index);

    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return Whether the srcLength field is set.
     */
    boolean hasSrcLength();
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return The srcLength.
     */
    long getSrcLength();

    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    java.util.List<Extent>
        getDstExtentsList();
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    Extent getDstExtents(int index);
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    int getDstExtentsCount();
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    java.util.List<? extends ExtentOrBuilder>
        getDstExtentsOrBuilderList();
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    ExtentOrBuilder getDstExtentsOrBuilder(
        int index);

    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return Whether the dstLength field is set.
     */
    boolean hasDstLength();
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return The dstLength.
     */
    long getDstLength();

    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return Whether the dataSha256Hash field is set.
     */
    boolean hasDataSha256Hash();
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return The dataSha256Hash.
     */
    com.google.protobuf.ByteString getDataSha256Hash();

    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return Whether the srcSha256Hash field is set.
     */
    boolean hasSrcSha256Hash();
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return The srcSha256Hash.
     */
    com.google.protobuf.ByteString getSrcSha256Hash();
  }
  /**
   * Protobuf type {@code InstallOperation}
   */
  public static final class InstallOperation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:InstallOperation)
      InstallOperationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InstallOperation.newBuilder() to construct.
    private InstallOperation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InstallOperation() {
      type_ = 0;
      srcExtents_ = java.util.Collections.emptyList();
      dstExtents_ = java.util.Collections.emptyList();
      dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new InstallOperation();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private InstallOperation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              Type value = Type.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                type_ = rawValue;
              }
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              dataOffset_ = input.readUInt64();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              dataLength_ = input.readUInt64();
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                srcExtents_ = new java.util.ArrayList<Extent>();
                mutable_bitField0_ |= 0x00000008;
              }
              srcExtents_.add(
                  input.readMessage(Extent.PARSER, extensionRegistry));
              break;
            }
            case 40: {
              bitField0_ |= 0x00000008;
              srcLength_ = input.readUInt64();
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                dstExtents_ = new java.util.ArrayList<Extent>();
                mutable_bitField0_ |= 0x00000020;
              }
              dstExtents_.add(
                  input.readMessage(Extent.PARSER, extensionRegistry));
              break;
            }
            case 56: {
              bitField0_ |= 0x00000010;
              dstLength_ = input.readUInt64();
              break;
            }
            case 66: {
              bitField0_ |= 0x00000020;
              dataSha256Hash_ = input.readBytes();
              break;
            }
            case 74: {
              bitField0_ |= 0x00000040;
              srcSha256Hash_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000008) != 0)) {
          srcExtents_ = java.util.Collections.unmodifiableList(srcExtents_);
        }
        if (((mutable_bitField0_ & 0x00000020) != 0)) {
          dstExtents_ = java.util.Collections.unmodifiableList(dstExtents_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              InstallOperation.class, Builder.class);
    }

    /**
     * Protobuf enum {@code InstallOperation.Type}
     */
    public enum Type
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Replace destination extents w/ attached data.
       * </pre>
       *
       * <code>REPLACE = 0;</code>
       */
      REPLACE(0),
      /**
       * <pre>
       * Replace destination extents w/ attached bzipped data.
       * </pre>
       *
       * <code>REPLACE_BZ = 1;</code>
       */
      REPLACE_BZ(1),
      /**
       * <pre>
       * Move source extents to target extents.
       * </pre>
       *
       * <code>MOVE = 2 [deprecated = true];</code>
       */
      @Deprecated
      MOVE(2),
      /**
       * <pre>
       * The data is a bsdiff binary diff.
       * </pre>
       *
       * <code>BSDIFF = 3 [deprecated = true];</code>
       */
      @Deprecated
      BSDIFF(3),
      /**
       * <pre>
       * On minor version 2 or newer, these operations are supported:
       * </pre>
       *
       * <code>SOURCE_COPY = 4;</code>
       */
      SOURCE_COPY(4),
      /**
       * <pre>
       * Like BSDIFF, but read from source partition
       * </pre>
       *
       * <code>SOURCE_BSDIFF = 5;</code>
       */
      SOURCE_BSDIFF(5),
      /**
       * <pre>
       * On minor version 3 or newer and on major version 2 or newer, these
       * operations are supported:
       * </pre>
       *
       * <code>REPLACE_XZ = 8;</code>
       */
      REPLACE_XZ(8),
      /**
       * <pre>
       * On minor version 4 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZERO = 6;</code>
       */
      ZERO(6),
      /**
       * <pre>
       * Discard the destination blocks, reading as undefined.
       * </pre>
       *
       * <code>DISCARD = 7;</code>
       */
      DISCARD(7),
      /**
       * <pre>
       * Like SOURCE_BSDIFF, but compressed with brotli.
       * </pre>
       *
       * <code>BROTLI_BSDIFF = 10;</code>
       */
      BROTLI_BSDIFF(10),
      /**
       * <pre>
       * On minor version 5 or newer, these operations are supported:
       * </pre>
       *
       * <code>PUFFDIFF = 9;</code>
       */
      PUFFDIFF(9),
      /**
       * <pre>
       * On minor version 8 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZUCCHINI = 11;</code>
       */
      ZUCCHINI(11),
      ;

      /**
       * <pre>
       * Replace destination extents w/ attached data.
       * </pre>
       *
       * <code>REPLACE = 0;</code>
       */
      public static final int REPLACE_VALUE = 0;
      /**
       * <pre>
       * Replace destination extents w/ attached bzipped data.
       * </pre>
       *
       * <code>REPLACE_BZ = 1;</code>
       */
      public static final int REPLACE_BZ_VALUE = 1;
      /**
       * <pre>
       * Move source extents to target extents.
       * </pre>
       *
       * <code>MOVE = 2 [deprecated = true];</code>
       */
      @Deprecated public static final int MOVE_VALUE = 2;
      /**
       * <pre>
       * The data is a bsdiff binary diff.
       * </pre>
       *
       * <code>BSDIFF = 3 [deprecated = true];</code>
       */
      @Deprecated public static final int BSDIFF_VALUE = 3;
      /**
       * <pre>
       * On minor version 2 or newer, these operations are supported:
       * </pre>
       *
       * <code>SOURCE_COPY = 4;</code>
       */
      public static final int SOURCE_COPY_VALUE = 4;
      /**
       * <pre>
       * Like BSDIFF, but read from source partition
       * </pre>
       *
       * <code>SOURCE_BSDIFF = 5;</code>
       */
      public static final int SOURCE_BSDIFF_VALUE = 5;
      /**
       * <pre>
       * On minor version 3 or newer and on major version 2 or newer, these
       * operations are supported:
       * </pre>
       *
       * <code>REPLACE_XZ = 8;</code>
       */
      public static final int REPLACE_XZ_VALUE = 8;
      /**
       * <pre>
       * On minor version 4 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZERO = 6;</code>
       */
      public static final int ZERO_VALUE = 6;
      /**
       * <pre>
       * Discard the destination blocks, reading as undefined.
       * </pre>
       *
       * <code>DISCARD = 7;</code>
       */
      public static final int DISCARD_VALUE = 7;
      /**
       * <pre>
       * Like SOURCE_BSDIFF, but compressed with brotli.
       * </pre>
       *
       * <code>BROTLI_BSDIFF = 10;</code>
       */
      public static final int BROTLI_BSDIFF_VALUE = 10;
      /**
       * <pre>
       * On minor version 5 or newer, these operations are supported:
       * </pre>
       *
       * <code>PUFFDIFF = 9;</code>
       */
      public static final int PUFFDIFF_VALUE = 9;
      /**
       * <pre>
       * On minor version 8 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZUCCHINI = 11;</code>
       */
      public static final int ZUCCHINI_VALUE = 11;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Type forNumber(int value) {
        switch (value) {
          case 0: return REPLACE;
          case 1: return REPLACE_BZ;
          case 2: return MOVE;
          case 3: return BSDIFF;
          case 4: return SOURCE_COPY;
          case 5: return SOURCE_BSDIFF;
          case 8: return REPLACE_XZ;
          case 6: return ZERO;
          case 7: return DISCARD;
          case 10: return BROTLI_BSDIFF;
          case 9: return PUFFDIFF;
          case 11: return ZUCCHINI;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return InstallOperation.getDescriptor().getEnumTypes().get(0);
      }

      private static final Type[] VALUES = values();

      public static Type valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:InstallOperation.Type)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>required .InstallOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .InstallOperation.Type type = 1;</code>
     * @return The type.
     */
    @Override public Type getType() {
      @SuppressWarnings("deprecation")
      Type result = Type.valueOf(type_);
      return result == null ? Type.REPLACE : result;
    }

    public static final int DATA_OFFSET_FIELD_NUMBER = 2;
    private long dataOffset_;
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return Whether the dataOffset field is set.
     */
    @Override
    public boolean hasDataOffset() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return The dataOffset.
     */
    @Override
    public long getDataOffset() {
      return dataOffset_;
    }

    public static final int DATA_LENGTH_FIELD_NUMBER = 3;
    private long dataLength_;
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return Whether the dataLength field is set.
     */
    @Override
    public boolean hasDataLength() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return The dataLength.
     */
    @Override
    public long getDataLength() {
      return dataLength_;
    }

    public static final int SRC_EXTENTS_FIELD_NUMBER = 4;
    private java.util.List<Extent> srcExtents_;
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    @Override
    public java.util.List<Extent> getSrcExtentsList() {
      return srcExtents_;
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    @Override
    public java.util.List<? extends ExtentOrBuilder>
        getSrcExtentsOrBuilderList() {
      return srcExtents_;
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    @Override
    public int getSrcExtentsCount() {
      return srcExtents_.size();
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    @Override
    public Extent getSrcExtents(int index) {
      return srcExtents_.get(index);
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .Extent src_extents = 4;</code>
     */
    @Override
    public ExtentOrBuilder getSrcExtentsOrBuilder(
        int index) {
      return srcExtents_.get(index);
    }

    public static final int SRC_LENGTH_FIELD_NUMBER = 5;
    private long srcLength_;
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return Whether the srcLength field is set.
     */
    @Override
    public boolean hasSrcLength() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return The srcLength.
     */
    @Override
    public long getSrcLength() {
      return srcLength_;
    }

    public static final int DST_EXTENTS_FIELD_NUMBER = 6;
    private java.util.List<Extent> dstExtents_;
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    @Override
    public java.util.List<Extent> getDstExtentsList() {
      return dstExtents_;
    }
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    @Override
    public java.util.List<? extends ExtentOrBuilder>
        getDstExtentsOrBuilderList() {
      return dstExtents_;
    }
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    @Override
    public int getDstExtentsCount() {
      return dstExtents_.size();
    }
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    @Override
    public Extent getDstExtents(int index) {
      return dstExtents_.get(index);
    }
    /**
     * <code>repeated .Extent dst_extents = 6;</code>
     */
    @Override
    public ExtentOrBuilder getDstExtentsOrBuilder(
        int index) {
      return dstExtents_.get(index);
    }

    public static final int DST_LENGTH_FIELD_NUMBER = 7;
    private long dstLength_;
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return Whether the dstLength field is set.
     */
    @Override
    public boolean hasDstLength() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return The dstLength.
     */
    @Override
    public long getDstLength() {
      return dstLength_;
    }

    public static final int DATA_SHA256_HASH_FIELD_NUMBER = 8;
    private com.google.protobuf.ByteString dataSha256Hash_;
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return Whether the dataSha256Hash field is set.
     */
    @Override
    public boolean hasDataSha256Hash() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return The dataSha256Hash.
     */
    @Override
    public com.google.protobuf.ByteString getDataSha256Hash() {
      return dataSha256Hash_;
    }

    public static final int SRC_SHA256_HASH_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString srcSha256Hash_;
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return Whether the srcSha256Hash field is set.
     */
    @Override
    public boolean hasSrcSha256Hash() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return The srcSha256Hash.
     */
    @Override
    public com.google.protobuf.ByteString getSrcSha256Hash() {
      return srcSha256Hash_;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, dataOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(3, dataLength_);
      }
      for (int i = 0; i < srcExtents_.size(); i++) {
        output.writeMessage(4, srcExtents_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt64(5, srcLength_);
      }
      for (int i = 0; i < dstExtents_.size(); i++) {
        output.writeMessage(6, dstExtents_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt64(7, dstLength_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBytes(8, dataSha256Hash_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBytes(9, srcSha256Hash_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, dataOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, dataLength_);
      }
      for (int i = 0; i < srcExtents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, srcExtents_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, srcLength_);
      }
      for (int i = 0; i < dstExtents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, dstExtents_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(7, dstLength_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(8, dataSha256Hash_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(9, srcSha256Hash_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof InstallOperation)) {
        return super.equals(obj);
      }
      InstallOperation other = (InstallOperation) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasDataOffset() != other.hasDataOffset()) return false;
      if (hasDataOffset()) {
        if (getDataOffset()
            != other.getDataOffset()) return false;
      }
      if (hasDataLength() != other.hasDataLength()) return false;
      if (hasDataLength()) {
        if (getDataLength()
            != other.getDataLength()) return false;
      }
      if (!getSrcExtentsList()
          .equals(other.getSrcExtentsList())) return false;
      if (hasSrcLength() != other.hasSrcLength()) return false;
      if (hasSrcLength()) {
        if (getSrcLength()
            != other.getSrcLength()) return false;
      }
      if (!getDstExtentsList()
          .equals(other.getDstExtentsList())) return false;
      if (hasDstLength() != other.hasDstLength()) return false;
      if (hasDstLength()) {
        if (getDstLength()
            != other.getDstLength()) return false;
      }
      if (hasDataSha256Hash() != other.hasDataSha256Hash()) return false;
      if (hasDataSha256Hash()) {
        if (!getDataSha256Hash()
            .equals(other.getDataSha256Hash())) return false;
      }
      if (hasSrcSha256Hash() != other.hasSrcSha256Hash()) return false;
      if (hasSrcSha256Hash()) {
        if (!getSrcSha256Hash()
            .equals(other.getSrcSha256Hash())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasDataOffset()) {
        hash = (37 * hash) + DATA_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDataOffset());
      }
      if (hasDataLength()) {
        hash = (37 * hash) + DATA_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDataLength());
      }
      if (getSrcExtentsCount() > 0) {
        hash = (37 * hash) + SRC_EXTENTS_FIELD_NUMBER;
        hash = (53 * hash) + getSrcExtentsList().hashCode();
      }
      if (hasSrcLength()) {
        hash = (37 * hash) + SRC_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSrcLength());
      }
      if (getDstExtentsCount() > 0) {
        hash = (37 * hash) + DST_EXTENTS_FIELD_NUMBER;
        hash = (53 * hash) + getDstExtentsList().hashCode();
      }
      if (hasDstLength()) {
        hash = (37 * hash) + DST_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDstLength());
      }
      if (hasDataSha256Hash()) {
        hash = (37 * hash) + DATA_SHA256_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getDataSha256Hash().hashCode();
      }
      if (hasSrcSha256Hash()) {
        hash = (37 * hash) + SRC_SHA256_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getSrcSha256Hash().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static InstallOperation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static InstallOperation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static InstallOperation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static InstallOperation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static InstallOperation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static InstallOperation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static InstallOperation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static InstallOperation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static InstallOperation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static InstallOperation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static InstallOperation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static InstallOperation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(InstallOperation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code InstallOperation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:InstallOperation)
        InstallOperationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                InstallOperation.class, Builder.class);
      }

      // Construct using UpdateMetadata.InstallOperation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSrcExtentsFieldBuilder();
          getDstExtentsFieldBuilder();
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        type_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        dataOffset_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        dataLength_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (srcExtentsBuilder_ == null) {
          srcExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          srcExtentsBuilder_.clear();
        }
        srcLength_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (dstExtentsBuilder_ == null) {
          dstExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          dstExtentsBuilder_.clear();
        }
        dstLength_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000040);
        dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
      }

      @Override
      public InstallOperation getDefaultInstanceForType() {
        return InstallOperation.getDefaultInstance();
      }

      @Override
      public InstallOperation build() {
        InstallOperation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public InstallOperation buildPartial() {
        InstallOperation result = new InstallOperation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.dataOffset_ = dataOffset_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.dataLength_ = dataLength_;
          to_bitField0_ |= 0x00000004;
        }
        if (srcExtentsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            srcExtents_ = java.util.Collections.unmodifiableList(srcExtents_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.srcExtents_ = srcExtents_;
        } else {
          result.srcExtents_ = srcExtentsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.srcLength_ = srcLength_;
          to_bitField0_ |= 0x00000008;
        }
        if (dstExtentsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            dstExtents_ = java.util.Collections.unmodifiableList(dstExtents_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.dstExtents_ = dstExtents_;
        } else {
          result.dstExtents_ = dstExtentsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.dstLength_ = dstLength_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.dataSha256Hash_ = dataSha256Hash_;
        if (((from_bitField0_ & 0x00000100) != 0)) {
          to_bitField0_ |= 0x00000040;
        }
        result.srcSha256Hash_ = srcSha256Hash_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof InstallOperation) {
          return mergeFrom((InstallOperation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(InstallOperation other) {
        if (other == InstallOperation.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasDataOffset()) {
          setDataOffset(other.getDataOffset());
        }
        if (other.hasDataLength()) {
          setDataLength(other.getDataLength());
        }
        if (srcExtentsBuilder_ == null) {
          if (!other.srcExtents_.isEmpty()) {
            if (srcExtents_.isEmpty()) {
              srcExtents_ = other.srcExtents_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureSrcExtentsIsMutable();
              srcExtents_.addAll(other.srcExtents_);
            }
            onChanged();
          }
        } else {
          if (!other.srcExtents_.isEmpty()) {
            if (srcExtentsBuilder_.isEmpty()) {
              srcExtentsBuilder_.dispose();
              srcExtentsBuilder_ = null;
              srcExtents_ = other.srcExtents_;
              bitField0_ = (bitField0_ & ~0x00000008);
              srcExtentsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSrcExtentsFieldBuilder() : null;
            } else {
              srcExtentsBuilder_.addAllMessages(other.srcExtents_);
            }
          }
        }
        if (other.hasSrcLength()) {
          setSrcLength(other.getSrcLength());
        }
        if (dstExtentsBuilder_ == null) {
          if (!other.dstExtents_.isEmpty()) {
            if (dstExtents_.isEmpty()) {
              dstExtents_ = other.dstExtents_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureDstExtentsIsMutable();
              dstExtents_.addAll(other.dstExtents_);
            }
            onChanged();
          }
        } else {
          if (!other.dstExtents_.isEmpty()) {
            if (dstExtentsBuilder_.isEmpty()) {
              dstExtentsBuilder_.dispose();
              dstExtentsBuilder_ = null;
              dstExtents_ = other.dstExtents_;
              bitField0_ = (bitField0_ & ~0x00000020);
              dstExtentsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getDstExtentsFieldBuilder() : null;
            } else {
              dstExtentsBuilder_.addAllMessages(other.dstExtents_);
            }
          }
        }
        if (other.hasDstLength()) {
          setDstLength(other.getDstLength());
        }
        if (other.hasDataSha256Hash()) {
          setDataSha256Hash(other.getDataSha256Hash());
        }
        if (other.hasSrcSha256Hash()) {
          setSrcSha256Hash(other.getSrcSha256Hash());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        InstallOperation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (InstallOperation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>required .InstallOperation.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .InstallOperation.Type type = 1;</code>
       * @return The type.
       */
      @Override
      public Type getType() {
        @SuppressWarnings("deprecation")
        Type result = Type.valueOf(type_);
        return result == null ? Type.REPLACE : result;
      }
      /**
       * <code>required .InstallOperation.Type type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .InstallOperation.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private long dataOffset_ ;
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return Whether the dataOffset field is set.
       */
      @Override
      public boolean hasDataOffset() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return The dataOffset.
       */
      @Override
      public long getDataOffset() {
        return dataOffset_;
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @param value The dataOffset to set.
       * @return This builder for chaining.
       */
      public Builder setDataOffset(long value) {
        bitField0_ |= 0x00000002;
        dataOffset_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataOffset() {
        bitField0_ = (bitField0_ & ~0x00000002);
        dataOffset_ = 0L;
        onChanged();
        return this;
      }

      private long dataLength_ ;
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return Whether the dataLength field is set.
       */
      @Override
      public boolean hasDataLength() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return The dataLength.
       */
      @Override
      public long getDataLength() {
        return dataLength_;
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @param value The dataLength to set.
       * @return This builder for chaining.
       */
      public Builder setDataLength(long value) {
        bitField0_ |= 0x00000004;
        dataLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataLength() {
        bitField0_ = (bitField0_ & ~0x00000004);
        dataLength_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<Extent> srcExtents_ =
        java.util.Collections.emptyList();
      private void ensureSrcExtentsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          srcExtents_ = new java.util.ArrayList<Extent>(srcExtents_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> srcExtentsBuilder_;

      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public java.util.List<Extent> getSrcExtentsList() {
        if (srcExtentsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(srcExtents_);
        } else {
          return srcExtentsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public int getSrcExtentsCount() {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.size();
        } else {
          return srcExtentsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Extent getSrcExtents(int index) {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.get(index);
        } else {
          return srcExtentsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder setSrcExtents(
          int index, Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.set(index, value);
          onChanged();
        } else {
          srcExtentsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder setSrcExtents(
          int index, Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.set(index, builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.add(value);
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          int index, Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.add(index, value);
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.add(builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          int index, Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.add(index, builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder addAllSrcExtents(
          Iterable<? extends Extent> values) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, srcExtents_);
          onChanged();
        } else {
          srcExtentsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder clearSrcExtents() {
        if (srcExtentsBuilder_ == null) {
          srcExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          srcExtentsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Builder removeSrcExtents(int index) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.remove(index);
          onChanged();
        } else {
          srcExtentsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Extent.Builder getSrcExtentsBuilder(
          int index) {
        return getSrcExtentsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public ExtentOrBuilder getSrcExtentsOrBuilder(
          int index) {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.get(index);  } else {
          return srcExtentsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public java.util.List<? extends ExtentOrBuilder>
           getSrcExtentsOrBuilderList() {
        if (srcExtentsBuilder_ != null) {
          return srcExtentsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(srcExtents_);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Extent.Builder addSrcExtentsBuilder() {
        return getSrcExtentsFieldBuilder().addBuilder(
            Extent.getDefaultInstance());
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public Extent.Builder addSrcExtentsBuilder(
          int index) {
        return getSrcExtentsFieldBuilder().addBuilder(
            index, Extent.getDefaultInstance());
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .Extent src_extents = 4;</code>
       */
      public java.util.List<Extent.Builder>
           getSrcExtentsBuilderList() {
        return getSrcExtentsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getSrcExtentsFieldBuilder() {
        if (srcExtentsBuilder_ == null) {
          srcExtentsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  srcExtents_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          srcExtents_ = null;
        }
        return srcExtentsBuilder_;
      }

      private long srcLength_ ;
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return Whether the srcLength field is set.
       */
      @Override
      public boolean hasSrcLength() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return The srcLength.
       */
      @Override
      public long getSrcLength() {
        return srcLength_;
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @param value The srcLength to set.
       * @return This builder for chaining.
       */
      public Builder setSrcLength(long value) {
        bitField0_ |= 0x00000010;
        srcLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcLength() {
        bitField0_ = (bitField0_ & ~0x00000010);
        srcLength_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<Extent> dstExtents_ =
        java.util.Collections.emptyList();
      private void ensureDstExtentsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          dstExtents_ = new java.util.ArrayList<Extent>(dstExtents_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> dstExtentsBuilder_;

      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public java.util.List<Extent> getDstExtentsList() {
        if (dstExtentsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(dstExtents_);
        } else {
          return dstExtentsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public int getDstExtentsCount() {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.size();
        } else {
          return dstExtentsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Extent getDstExtents(int index) {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.get(index);
        } else {
          return dstExtentsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder setDstExtents(
          int index, Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.set(index, value);
          onChanged();
        } else {
          dstExtentsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder setDstExtents(
          int index, Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.set(index, builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.add(value);
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          int index, Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.add(index, value);
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.add(builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          int index, Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.add(index, builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder addAllDstExtents(
          Iterable<? extends Extent> values) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, dstExtents_);
          onChanged();
        } else {
          dstExtentsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder clearDstExtents() {
        if (dstExtentsBuilder_ == null) {
          dstExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          dstExtentsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Builder removeDstExtents(int index) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.remove(index);
          onChanged();
        } else {
          dstExtentsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Extent.Builder getDstExtentsBuilder(
          int index) {
        return getDstExtentsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public ExtentOrBuilder getDstExtentsOrBuilder(
          int index) {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.get(index);  } else {
          return dstExtentsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public java.util.List<? extends ExtentOrBuilder>
           getDstExtentsOrBuilderList() {
        if (dstExtentsBuilder_ != null) {
          return dstExtentsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(dstExtents_);
        }
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Extent.Builder addDstExtentsBuilder() {
        return getDstExtentsFieldBuilder().addBuilder(
            Extent.getDefaultInstance());
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public Extent.Builder addDstExtentsBuilder(
          int index) {
        return getDstExtentsFieldBuilder().addBuilder(
            index, Extent.getDefaultInstance());
      }
      /**
       * <code>repeated .Extent dst_extents = 6;</code>
       */
      public java.util.List<Extent.Builder>
           getDstExtentsBuilderList() {
        return getDstExtentsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getDstExtentsFieldBuilder() {
        if (dstExtentsBuilder_ == null) {
          dstExtentsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  dstExtents_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          dstExtents_ = null;
        }
        return dstExtentsBuilder_;
      }

      private long dstLength_ ;
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return Whether the dstLength field is set.
       */
      @Override
      public boolean hasDstLength() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return The dstLength.
       */
      @Override
      public long getDstLength() {
        return dstLength_;
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @param value The dstLength to set.
       * @return This builder for chaining.
       */
      public Builder setDstLength(long value) {
        bitField0_ |= 0x00000040;
        dstLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDstLength() {
        bitField0_ = (bitField0_ & ~0x00000040);
        dstLength_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return Whether the dataSha256Hash field is set.
       */
      @Override
      public boolean hasDataSha256Hash() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return The dataSha256Hash.
       */
      @Override
      public com.google.protobuf.ByteString getDataSha256Hash() {
        return dataSha256Hash_;
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @param value The dataSha256Hash to set.
       * @return This builder for chaining.
       */
      public Builder setDataSha256Hash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        dataSha256Hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataSha256Hash() {
        bitField0_ = (bitField0_ & ~0x00000080);
        dataSha256Hash_ = getDefaultInstance().getDataSha256Hash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return Whether the srcSha256Hash field is set.
       */
      @Override
      public boolean hasSrcSha256Hash() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return The srcSha256Hash.
       */
      @Override
      public com.google.protobuf.ByteString getSrcSha256Hash() {
        return srcSha256Hash_;
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @param value The srcSha256Hash to set.
       * @return This builder for chaining.
       */
      public Builder setSrcSha256Hash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
        srcSha256Hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcSha256Hash() {
        bitField0_ = (bitField0_ & ~0x00000100);
        srcSha256Hash_ = getDefaultInstance().getSrcSha256Hash();
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:InstallOperation)
    }

    // @@protoc_insertion_point(class_scope:InstallOperation)
    private static final InstallOperation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new InstallOperation();
    }

    public static InstallOperation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<InstallOperation>
        PARSER = new com.google.protobuf.AbstractParser<InstallOperation>() {
      @Override
      public InstallOperation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new InstallOperation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InstallOperation> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<InstallOperation> getParserForType() {
      return PARSER;
    }

    @Override
    public InstallOperation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CowMergeOperationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:CowMergeOperation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional .CowMergeOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>optional .CowMergeOperation.Type type = 1;</code>
     * @return The type.
     */
    CowMergeOperation.Type getType();

    /**
     * <code>optional .Extent src_extent = 2;</code>
     * @return Whether the srcExtent field is set.
     */
    boolean hasSrcExtent();
    /**
     * <code>optional .Extent src_extent = 2;</code>
     * @return The srcExtent.
     */
    Extent getSrcExtent();
    /**
     * <code>optional .Extent src_extent = 2;</code>
     */
    ExtentOrBuilder getSrcExtentOrBuilder();

    /**
     * <code>optional .Extent dst_extent = 3;</code>
     * @return Whether the dstExtent field is set.
     */
    boolean hasDstExtent();
    /**
     * <code>optional .Extent dst_extent = 3;</code>
     * @return The dstExtent.
     */
    Extent getDstExtent();
    /**
     * <code>optional .Extent dst_extent = 3;</code>
     */
    ExtentOrBuilder getDstExtentOrBuilder();

    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return Whether the srcOffset field is set.
     */
    boolean hasSrcOffset();
    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return The srcOffset.
     */
    int getSrcOffset();
  }
  /**
   * <pre>
   * Hints to VAB snapshot to skip writing some blocks if these blocks are
   * identical to the ones on the source image. The src &amp; dst extents for each
   * CowMergeOperation should be contiguous, and they're a subset of an OTA
   * InstallOperation.
   * During merge time, we need to follow the pre-computed sequence to avoid
   * read after write, similar to the inplace update schema.
   * </pre>
   *
   * Protobuf type {@code CowMergeOperation}
   */
  public static final class CowMergeOperation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:CowMergeOperation)
      CowMergeOperationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CowMergeOperation.newBuilder() to construct.
    private CowMergeOperation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CowMergeOperation() {
      type_ = 0;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new CowMergeOperation();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CowMergeOperation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              Type value = Type.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                type_ = rawValue;
              }
              break;
            }
            case 18: {
              Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) != 0)) {
                subBuilder = srcExtent_.toBuilder();
              }
              srcExtent_ = input.readMessage(Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(srcExtent_);
                srcExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) != 0)) {
                subBuilder = dstExtent_.toBuilder();
              }
              dstExtent_ = input.readMessage(Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(dstExtent_);
                dstExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              srcOffset_ = input.readUInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              CowMergeOperation.class, Builder.class);
    }

    /**
     * Protobuf enum {@code CowMergeOperation.Type}
     */
    public enum Type
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * identical blocks
       * </pre>
       *
       * <code>COW_COPY = 0;</code>
       */
      COW_COPY(0),
      /**
       * <pre>
       * used when src/dst blocks are highly similar
       * </pre>
       *
       * <code>COW_XOR = 1;</code>
       */
      COW_XOR(1),
      /**
       * <pre>
       * Raw replace operation
       * </pre>
       *
       * <code>COW_REPLACE = 2;</code>
       */
      COW_REPLACE(2),
      ;

      /**
       * <pre>
       * identical blocks
       * </pre>
       *
       * <code>COW_COPY = 0;</code>
       */
      public static final int COW_COPY_VALUE = 0;
      /**
       * <pre>
       * used when src/dst blocks are highly similar
       * </pre>
       *
       * <code>COW_XOR = 1;</code>
       */
      public static final int COW_XOR_VALUE = 1;
      /**
       * <pre>
       * Raw replace operation
       * </pre>
       *
       * <code>COW_REPLACE = 2;</code>
       */
      public static final int COW_REPLACE_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Type forNumber(int value) {
        switch (value) {
          case 0: return COW_COPY;
          case 1: return COW_XOR;
          case 2: return COW_REPLACE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return CowMergeOperation.getDescriptor().getEnumTypes().get(0);
      }

      private static final Type[] VALUES = values();

      public static Type valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:CowMergeOperation.Type)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>optional .CowMergeOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .CowMergeOperation.Type type = 1;</code>
     * @return The type.
     */
    @Override public Type getType() {
      @SuppressWarnings("deprecation")
      Type result = Type.valueOf(type_);
      return result == null ? Type.COW_COPY : result;
    }

    public static final int SRC_EXTENT_FIELD_NUMBER = 2;
    private Extent srcExtent_;
    /**
     * <code>optional .Extent src_extent = 2;</code>
     * @return Whether the srcExtent field is set.
     */
    @Override
    public boolean hasSrcExtent() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .Extent src_extent = 2;</code>
     * @return The srcExtent.
     */
    @Override
    public Extent getSrcExtent() {
      return srcExtent_ == null ? Extent.getDefaultInstance() : srcExtent_;
    }
    /**
     * <code>optional .Extent src_extent = 2;</code>
     */
    @Override
    public ExtentOrBuilder getSrcExtentOrBuilder() {
      return srcExtent_ == null ? Extent.getDefaultInstance() : srcExtent_;
    }

    public static final int DST_EXTENT_FIELD_NUMBER = 3;
    private Extent dstExtent_;
    /**
     * <code>optional .Extent dst_extent = 3;</code>
     * @return Whether the dstExtent field is set.
     */
    @Override
    public boolean hasDstExtent() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .Extent dst_extent = 3;</code>
     * @return The dstExtent.
     */
    @Override
    public Extent getDstExtent() {
      return dstExtent_ == null ? Extent.getDefaultInstance() : dstExtent_;
    }
    /**
     * <code>optional .Extent dst_extent = 3;</code>
     */
    @Override
    public ExtentOrBuilder getDstExtentOrBuilder() {
      return dstExtent_ == null ? Extent.getDefaultInstance() : dstExtent_;
    }

    public static final int SRC_OFFSET_FIELD_NUMBER = 4;
    private int srcOffset_;
    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return Whether the srcOffset field is set.
     */
    @Override
    public boolean hasSrcOffset() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return The srcOffset.
     */
    @Override
    public int getSrcOffset() {
      return srcOffset_;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSrcExtent());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getDstExtent());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(4, srcOffset_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSrcExtent());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getDstExtent());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, srcOffset_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof CowMergeOperation)) {
        return super.equals(obj);
      }
      CowMergeOperation other = (CowMergeOperation) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasSrcExtent() != other.hasSrcExtent()) return false;
      if (hasSrcExtent()) {
        if (!getSrcExtent()
            .equals(other.getSrcExtent())) return false;
      }
      if (hasDstExtent() != other.hasDstExtent()) return false;
      if (hasDstExtent()) {
        if (!getDstExtent()
            .equals(other.getDstExtent())) return false;
      }
      if (hasSrcOffset() != other.hasSrcOffset()) return false;
      if (hasSrcOffset()) {
        if (getSrcOffset()
            != other.getSrcOffset()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasSrcExtent()) {
        hash = (37 * hash) + SRC_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getSrcExtent().hashCode();
      }
      if (hasDstExtent()) {
        hash = (37 * hash) + DST_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getDstExtent().hashCode();
      }
      if (hasSrcOffset()) {
        hash = (37 * hash) + SRC_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + getSrcOffset();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static CowMergeOperation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static CowMergeOperation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static CowMergeOperation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static CowMergeOperation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static CowMergeOperation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static CowMergeOperation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static CowMergeOperation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static CowMergeOperation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static CowMergeOperation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static CowMergeOperation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static CowMergeOperation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static CowMergeOperation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(CowMergeOperation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Hints to VAB snapshot to skip writing some blocks if these blocks are
     * identical to the ones on the source image. The src &amp; dst extents for each
     * CowMergeOperation should be contiguous, and they're a subset of an OTA
     * InstallOperation.
     * During merge time, we need to follow the pre-computed sequence to avoid
     * read after write, similar to the inplace update schema.
     * </pre>
     *
     * Protobuf type {@code CowMergeOperation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:CowMergeOperation)
        CowMergeOperationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                CowMergeOperation.class, Builder.class);
      }

      // Construct using UpdateMetadata.CowMergeOperation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSrcExtentFieldBuilder();
          getDstExtentFieldBuilder();
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        type_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (srcExtentBuilder_ == null) {
          srcExtent_ = null;
        } else {
          srcExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (dstExtentBuilder_ == null) {
          dstExtent_ = null;
        } else {
          dstExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        srcOffset_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
      }

      @Override
      public CowMergeOperation getDefaultInstanceForType() {
        return CowMergeOperation.getDefaultInstance();
      }

      @Override
      public CowMergeOperation build() {
        CowMergeOperation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public CowMergeOperation buildPartial() {
        CowMergeOperation result = new CowMergeOperation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          if (srcExtentBuilder_ == null) {
            result.srcExtent_ = srcExtent_;
          } else {
            result.srcExtent_ = srcExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          if (dstExtentBuilder_ == null) {
            result.dstExtent_ = dstExtent_;
          } else {
            result.dstExtent_ = dstExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.srcOffset_ = srcOffset_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof CowMergeOperation) {
          return mergeFrom((CowMergeOperation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(CowMergeOperation other) {
        if (other == CowMergeOperation.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasSrcExtent()) {
          mergeSrcExtent(other.getSrcExtent());
        }
        if (other.hasDstExtent()) {
          mergeDstExtent(other.getDstExtent());
        }
        if (other.hasSrcOffset()) {
          setSrcOffset(other.getSrcOffset());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        CowMergeOperation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (CowMergeOperation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>optional .CowMergeOperation.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional .CowMergeOperation.Type type = 1;</code>
       * @return The type.
       */
      @Override
      public Type getType() {
        @SuppressWarnings("deprecation")
        Type result = Type.valueOf(type_);
        return result == null ? Type.COW_COPY : result;
      }
      /**
       * <code>optional .CowMergeOperation.Type type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .CowMergeOperation.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private Extent srcExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> srcExtentBuilder_;
      /**
       * <code>optional .Extent src_extent = 2;</code>
       * @return Whether the srcExtent field is set.
       */
      public boolean hasSrcExtent() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       * @return The srcExtent.
       */
      public Extent getSrcExtent() {
        if (srcExtentBuilder_ == null) {
          return srcExtent_ == null ? Extent.getDefaultInstance() : srcExtent_;
        } else {
          return srcExtentBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       */
      public Builder setSrcExtent(Extent value) {
        if (srcExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          srcExtent_ = value;
          onChanged();
        } else {
          srcExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       */
      public Builder setSrcExtent(
          Extent.Builder builderForValue) {
        if (srcExtentBuilder_ == null) {
          srcExtent_ = builderForValue.build();
          onChanged();
        } else {
          srcExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       */
      public Builder mergeSrcExtent(Extent value) {
        if (srcExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
              srcExtent_ != null &&
              srcExtent_ != Extent.getDefaultInstance()) {
            srcExtent_ =
              Extent.newBuilder(srcExtent_).mergeFrom(value).buildPartial();
          } else {
            srcExtent_ = value;
          }
          onChanged();
        } else {
          srcExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       */
      public Builder clearSrcExtent() {
        if (srcExtentBuilder_ == null) {
          srcExtent_ = null;
          onChanged();
        } else {
          srcExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       */
      public Extent.Builder getSrcExtentBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSrcExtentFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       */
      public ExtentOrBuilder getSrcExtentOrBuilder() {
        if (srcExtentBuilder_ != null) {
          return srcExtentBuilder_.getMessageOrBuilder();
        } else {
          return srcExtent_ == null ?
              Extent.getDefaultInstance() : srcExtent_;
        }
      }
      /**
       * <code>optional .Extent src_extent = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getSrcExtentFieldBuilder() {
        if (srcExtentBuilder_ == null) {
          srcExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  getSrcExtent(),
                  getParentForChildren(),
                  isClean());
          srcExtent_ = null;
        }
        return srcExtentBuilder_;
      }

      private Extent dstExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> dstExtentBuilder_;
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       * @return Whether the dstExtent field is set.
       */
      public boolean hasDstExtent() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       * @return The dstExtent.
       */
      public Extent getDstExtent() {
        if (dstExtentBuilder_ == null) {
          return dstExtent_ == null ? Extent.getDefaultInstance() : dstExtent_;
        } else {
          return dstExtentBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       */
      public Builder setDstExtent(Extent value) {
        if (dstExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          dstExtent_ = value;
          onChanged();
        } else {
          dstExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       */
      public Builder setDstExtent(
          Extent.Builder builderForValue) {
        if (dstExtentBuilder_ == null) {
          dstExtent_ = builderForValue.build();
          onChanged();
        } else {
          dstExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       */
      public Builder mergeDstExtent(Extent value) {
        if (dstExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
              dstExtent_ != null &&
              dstExtent_ != Extent.getDefaultInstance()) {
            dstExtent_ =
              Extent.newBuilder(dstExtent_).mergeFrom(value).buildPartial();
          } else {
            dstExtent_ = value;
          }
          onChanged();
        } else {
          dstExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       */
      public Builder clearDstExtent() {
        if (dstExtentBuilder_ == null) {
          dstExtent_ = null;
          onChanged();
        } else {
          dstExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       */
      public Extent.Builder getDstExtentBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getDstExtentFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       */
      public ExtentOrBuilder getDstExtentOrBuilder() {
        if (dstExtentBuilder_ != null) {
          return dstExtentBuilder_.getMessageOrBuilder();
        } else {
          return dstExtent_ == null ?
              Extent.getDefaultInstance() : dstExtent_;
        }
      }
      /**
       * <code>optional .Extent dst_extent = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getDstExtentFieldBuilder() {
        if (dstExtentBuilder_ == null) {
          dstExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  getDstExtent(),
                  getParentForChildren(),
                  isClean());
          dstExtent_ = null;
        }
        return dstExtentBuilder_;
      }

      private int srcOffset_ ;
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @return Whether the srcOffset field is set.
       */
      @Override
      public boolean hasSrcOffset() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @return The srcOffset.
       */
      @Override
      public int getSrcOffset() {
        return srcOffset_;
      }
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @param value The srcOffset to set.
       * @return This builder for chaining.
       */
      public Builder setSrcOffset(int value) {
        bitField0_ |= 0x00000008;
        srcOffset_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcOffset() {
        bitField0_ = (bitField0_ & ~0x00000008);
        srcOffset_ = 0;
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:CowMergeOperation)
    }

    // @@protoc_insertion_point(class_scope:CowMergeOperation)
    private static final CowMergeOperation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new CowMergeOperation();
    }

    public static CowMergeOperation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<CowMergeOperation>
        PARSER = new com.google.protobuf.AbstractParser<CowMergeOperation>() {
      @Override
      public CowMergeOperation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CowMergeOperation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CowMergeOperation> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<CowMergeOperation> getParserForType() {
      return PARSER;
    }

    @Override
    public CowMergeOperation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartitionUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:PartitionUpdate)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return Whether the partitionName field is set.
     */
    boolean hasPartitionName();
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The partitionName.
     */
    String getPartitionName();
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The bytes for partitionName.
     */
    com.google.protobuf.ByteString
        getPartitionNameBytes();

    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return Whether the runPostinstall field is set.
     */
    boolean hasRunPostinstall();
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return The runPostinstall.
     */
    boolean getRunPostinstall();

    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return Whether the postinstallPath field is set.
     */
    boolean hasPostinstallPath();
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The postinstallPath.
     */
    String getPostinstallPath();
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The bytes for postinstallPath.
     */
    com.google.protobuf.ByteString
        getPostinstallPathBytes();

    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return Whether the filesystemType field is set.
     */
    boolean hasFilesystemType();
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The filesystemType.
     */
    String getFilesystemType();
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The bytes for filesystemType.
     */
    com.google.protobuf.ByteString
        getFilesystemTypeBytes();

    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    java.util.List<Signatures.Signature>
        getNewPartitionSignatureList();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    Signatures.Signature getNewPartitionSignature(int index);
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    int getNewPartitionSignatureCount();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    java.util.List<? extends Signatures.SignatureOrBuilder>
        getNewPartitionSignatureOrBuilderList();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
        int index);

    /**
     * <code>optional .PartitionInfo old_partition_info = 6;</code>
     * @return Whether the oldPartitionInfo field is set.
     */
    boolean hasOldPartitionInfo();
    /**
     * <code>optional .PartitionInfo old_partition_info = 6;</code>
     * @return The oldPartitionInfo.
     */
    PartitionInfo getOldPartitionInfo();
    /**
     * <code>optional .PartitionInfo old_partition_info = 6;</code>
     */
    PartitionInfoOrBuilder getOldPartitionInfoOrBuilder();

    /**
     * <code>optional .PartitionInfo new_partition_info = 7;</code>
     * @return Whether the newPartitionInfo field is set.
     */
    boolean hasNewPartitionInfo();
    /**
     * <code>optional .PartitionInfo new_partition_info = 7;</code>
     * @return The newPartitionInfo.
     */
    PartitionInfo getNewPartitionInfo();
    /**
     * <code>optional .PartitionInfo new_partition_info = 7;</code>
     */
    PartitionInfoOrBuilder getNewPartitionInfoOrBuilder();

    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    java.util.List<InstallOperation>
        getOperationsList();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    InstallOperation getOperations(int index);
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    int getOperationsCount();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    java.util.List<? extends InstallOperationOrBuilder>
        getOperationsOrBuilderList();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    InstallOperationOrBuilder getOperationsOrBuilder(
        int index);

    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return Whether the postinstallOptional field is set.
     */
    boolean hasPostinstallOptional();
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return The postinstallOptional.
     */
    boolean getPostinstallOptional();

    /**
     * <pre>
     * On minor version 6 or newer, these fields are supported:
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_data_extent = 10;</code>
     * @return Whether the hashTreeDataExtent field is set.
     */
    boolean hasHashTreeDataExtent();
    /**
     * <pre>
     * On minor version 6 or newer, these fields are supported:
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_data_extent = 10;</code>
     * @return The hashTreeDataExtent.
     */
    Extent getHashTreeDataExtent();
    /**
     * <pre>
     * On minor version 6 or newer, these fields are supported:
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_data_extent = 10;</code>
     */
    ExtentOrBuilder getHashTreeDataExtentOrBuilder();

    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_extent = 11;</code>
     * @return Whether the hashTreeExtent field is set.
     */
    boolean hasHashTreeExtent();
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_extent = 11;</code>
     * @return The hashTreeExtent.
     */
    Extent getHashTreeExtent();
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_extent = 11;</code>
     */
    ExtentOrBuilder getHashTreeExtentOrBuilder();

    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return Whether the hashTreeAlgorithm field is set.
     */
    boolean hasHashTreeAlgorithm();
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The hashTreeAlgorithm.
     */
    String getHashTreeAlgorithm();
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The bytes for hashTreeAlgorithm.
     */
    com.google.protobuf.ByteString
        getHashTreeAlgorithmBytes();

    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return Whether the hashTreeSalt field is set.
     */
    boolean hasHashTreeSalt();
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return The hashTreeSalt.
     */
    com.google.protobuf.ByteString getHashTreeSalt();

    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .Extent fec_data_extent = 14;</code>
     * @return Whether the fecDataExtent field is set.
     */
    boolean hasFecDataExtent();
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .Extent fec_data_extent = 14;</code>
     * @return The fecDataExtent.
     */
    Extent getFecDataExtent();
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .Extent fec_data_extent = 14;</code>
     */
    ExtentOrBuilder getFecDataExtentOrBuilder();

    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .Extent fec_extent = 15;</code>
     * @return Whether the fecExtent field is set.
     */
    boolean hasFecExtent();
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .Extent fec_extent = 15;</code>
     * @return The fecExtent.
     */
    Extent getFecExtent();
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .Extent fec_extent = 15;</code>
     */
    ExtentOrBuilder getFecExtentOrBuilder();

    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return Whether the fecRoots field is set.
     */
    boolean hasFecRoots();
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return The fecRoots.
     */
    int getFecRoots();

    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The version.
     */
    String getVersion();
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    java.util.List<CowMergeOperation>
        getMergeOperationsList();
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    CowMergeOperation getMergeOperations(int index);
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    int getMergeOperationsCount();
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    java.util.List<? extends CowMergeOperationOrBuilder>
        getMergeOperationsOrBuilderList();
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    CowMergeOperationOrBuilder getMergeOperationsOrBuilder(
        int index);

    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return Whether the estimateCowSize field is set.
     */
    boolean hasEstimateCowSize();
    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return The estimateCowSize.
     */
    long getEstimateCowSize();
  }
  /**
   * <pre>
   * Describes the update to apply to a single partition.
   * </pre>
   *
   * Protobuf type {@code PartitionUpdate}
   */
  public static final class PartitionUpdate extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:PartitionUpdate)
      PartitionUpdateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PartitionUpdate.newBuilder() to construct.
    private PartitionUpdate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PartitionUpdate() {
      partitionName_ = "";
      postinstallPath_ = "";
      filesystemType_ = "";
      newPartitionSignature_ = java.util.Collections.emptyList();
      operations_ = java.util.Collections.emptyList();
      hashTreeAlgorithm_ = "";
      hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
      fecRoots_ = 2;
      version_ = "";
      mergeOperations_ = java.util.Collections.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new PartitionUpdate();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PartitionUpdate(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              partitionName_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              runPostinstall_ = input.readBool();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              postinstallPath_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              filesystemType_ = bs;
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) != 0)) {
                newPartitionSignature_ = new java.util.ArrayList<Signatures.Signature>();
                mutable_bitField0_ |= 0x00000010;
              }
              newPartitionSignature_.add(
                  input.readMessage(Signatures.Signature.PARSER, extensionRegistry));
              break;
            }
            case 50: {
              PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) != 0)) {
                subBuilder = oldPartitionInfo_.toBuilder();
              }
              oldPartitionInfo_ = input.readMessage(PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldPartitionInfo_);
                oldPartitionInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 58: {
              PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) != 0)) {
                subBuilder = newPartitionInfo_.toBuilder();
              }
              newPartitionInfo_ = input.readMessage(PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newPartitionInfo_);
                newPartitionInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 66: {
              if (!((mutable_bitField0_ & 0x00000080) != 0)) {
                operations_ = new java.util.ArrayList<InstallOperation>();
                mutable_bitField0_ |= 0x00000080;
              }
              operations_.add(
                  input.readMessage(InstallOperation.PARSER, extensionRegistry));
              break;
            }
            case 72: {
              bitField0_ |= 0x00000040;
              postinstallOptional_ = input.readBool();
              break;
            }
            case 82: {
              Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) != 0)) {
                subBuilder = hashTreeDataExtent_.toBuilder();
              }
              hashTreeDataExtent_ = input.readMessage(Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(hashTreeDataExtent_);
                hashTreeDataExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 90: {
              Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) != 0)) {
                subBuilder = hashTreeExtent_.toBuilder();
              }
              hashTreeExtent_ = input.readMessage(Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(hashTreeExtent_);
                hashTreeExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 98: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000200;
              hashTreeAlgorithm_ = bs;
              break;
            }
            case 106: {
              bitField0_ |= 0x00000400;
              hashTreeSalt_ = input.readBytes();
              break;
            }
            case 114: {
              Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000800) != 0)) {
                subBuilder = fecDataExtent_.toBuilder();
              }
              fecDataExtent_ = input.readMessage(Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(fecDataExtent_);
                fecDataExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000800;
              break;
            }
            case 122: {
              Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00001000) != 0)) {
                subBuilder = fecExtent_.toBuilder();
              }
              fecExtent_ = input.readMessage(Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(fecExtent_);
                fecExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00001000;
              break;
            }
            case 128: {
              bitField0_ |= 0x00002000;
              fecRoots_ = input.readUInt32();
              break;
            }
            case 138: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00004000;
              version_ = bs;
              break;
            }
            case 146: {
              if (!((mutable_bitField0_ & 0x00020000) != 0)) {
                mergeOperations_ = new java.util.ArrayList<CowMergeOperation>();
                mutable_bitField0_ |= 0x00020000;
              }
              mergeOperations_.add(
                  input.readMessage(CowMergeOperation.PARSER, extensionRegistry));
              break;
            }
            case 152: {
              bitField0_ |= 0x00008000;
              estimateCowSize_ = input.readUInt64();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000010) != 0)) {
          newPartitionSignature_ = java.util.Collections.unmodifiableList(newPartitionSignature_);
        }
        if (((mutable_bitField0_ & 0x00000080) != 0)) {
          operations_ = java.util.Collections.unmodifiableList(operations_);
        }
        if (((mutable_bitField0_ & 0x00020000) != 0)) {
          mergeOperations_ = java.util.Collections.unmodifiableList(mergeOperations_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              PartitionUpdate.class, Builder.class);
    }

    private int bitField0_;
    public static final int PARTITION_NAME_FIELD_NUMBER = 1;
    private volatile Object partitionName_;
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return Whether the partitionName field is set.
     */
    @Override
    public boolean hasPartitionName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The partitionName.
     */
    @Override
    public String getPartitionName() {
      Object ref = partitionName_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          partitionName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The bytes for partitionName.
     */
    @Override
    public com.google.protobuf.ByteString
        getPartitionNameBytes() {
      Object ref = partitionName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        partitionName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RUN_POSTINSTALL_FIELD_NUMBER = 2;
    private boolean runPostinstall_;
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return Whether the runPostinstall field is set.
     */
    @Override
    public boolean hasRunPostinstall() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return The runPostinstall.
     */
    @Override
    public boolean getRunPostinstall() {
      return runPostinstall_;
    }

    public static final int POSTINSTALL_PATH_FIELD_NUMBER = 3;
    private volatile Object postinstallPath_;
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return Whether the postinstallPath field is set.
     */
    @Override
    public boolean hasPostinstallPath() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The postinstallPath.
     */
    @Override
    public String getPostinstallPath() {
      Object ref = postinstallPath_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          postinstallPath_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The bytes for postinstallPath.
     */
    @Override
    public com.google.protobuf.ByteString
        getPostinstallPathBytes() {
      Object ref = postinstallPath_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        postinstallPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILESYSTEM_TYPE_FIELD_NUMBER = 4;
    private volatile Object filesystemType_;
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return Whether the filesystemType field is set.
     */
    @Override
    public boolean hasFilesystemType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The filesystemType.
     */
    @Override
    public String getFilesystemType() {
      Object ref = filesystemType_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          filesystemType_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The bytes for filesystemType.
     */
    @Override
    public com.google.protobuf.ByteString
        getFilesystemTypeBytes() {
      Object ref = filesystemType_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        filesystemType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NEW_PARTITION_SIGNATURE_FIELD_NUMBER = 5;
    private java.util.List<Signatures.Signature> newPartitionSignature_;
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    @Override
    public java.util.List<Signatures.Signature> getNewPartitionSignatureList() {
      return newPartitionSignature_;
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    @Override
    public java.util.List<? extends Signatures.SignatureOrBuilder>
        getNewPartitionSignatureOrBuilderList() {
      return newPartitionSignature_;
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    @Override
    public int getNewPartitionSignatureCount() {
      return newPartitionSignature_.size();
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    @Override
    public Signatures.Signature getNewPartitionSignature(int index) {
      return newPartitionSignature_.get(index);
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
     */
    @Override
    public Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
        int index) {
      return newPartitionSignature_.get(index);
    }

    public static final int OLD_PARTITION_INFO_FIELD_NUMBER = 6;
    private PartitionInfo oldPartitionInfo_;
    /**
     * <code>optional .PartitionInfo old_partition_info = 6;</code>
     * @return Whether the oldPartitionInfo field is set.
     */
    @Override
    public boolean hasOldPartitionInfo() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .PartitionInfo old_partition_info = 6;</code>
     * @return The oldPartitionInfo.
     */
    @Override
    public PartitionInfo getOldPartitionInfo() {
      return oldPartitionInfo_ == null ? PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
    }
    /**
     * <code>optional .PartitionInfo old_partition_info = 6;</code>
     */
    @Override
    public PartitionInfoOrBuilder getOldPartitionInfoOrBuilder() {
      return oldPartitionInfo_ == null ? PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
    }

    public static final int NEW_PARTITION_INFO_FIELD_NUMBER = 7;
    private PartitionInfo newPartitionInfo_;
    /**
     * <code>optional .PartitionInfo new_partition_info = 7;</code>
     * @return Whether the newPartitionInfo field is set.
     */
    @Override
    public boolean hasNewPartitionInfo() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .PartitionInfo new_partition_info = 7;</code>
     * @return The newPartitionInfo.
     */
    @Override
    public PartitionInfo getNewPartitionInfo() {
      return newPartitionInfo_ == null ? PartitionInfo.getDefaultInstance() : newPartitionInfo_;
    }
    /**
     * <code>optional .PartitionInfo new_partition_info = 7;</code>
     */
    @Override
    public PartitionInfoOrBuilder getNewPartitionInfoOrBuilder() {
      return newPartitionInfo_ == null ? PartitionInfo.getDefaultInstance() : newPartitionInfo_;
    }

    public static final int OPERATIONS_FIELD_NUMBER = 8;
    private java.util.List<InstallOperation> operations_;
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    @Override
    public java.util.List<InstallOperation> getOperationsList() {
      return operations_;
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    @Override
    public java.util.List<? extends InstallOperationOrBuilder>
        getOperationsOrBuilderList() {
      return operations_;
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    @Override
    public int getOperationsCount() {
      return operations_.size();
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    @Override
    public InstallOperation getOperations(int index) {
      return operations_.get(index);
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .InstallOperation operations = 8;</code>
     */
    @Override
    public InstallOperationOrBuilder getOperationsOrBuilder(
        int index) {
      return operations_.get(index);
    }

    public static final int POSTINSTALL_OPTIONAL_FIELD_NUMBER = 9;
    private boolean postinstallOptional_;
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return Whether the postinstallOptional field is set.
     */
    @Override
    public boolean hasPostinstallOptional() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return The postinstallOptional.
     */
    @Override
    public boolean getPostinstallOptional() {
      return postinstallOptional_;
    }

    public static final int HASH_TREE_DATA_EXTENT_FIELD_NUMBER = 10;
    private Extent hashTreeDataExtent_;
    /**
     * <pre>
     * On minor version 6 or newer, these fields are supported:
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_data_extent = 10;</code>
     * @return Whether the hashTreeDataExtent field is set.
     */
    @Override
    public boolean hasHashTreeDataExtent() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * On minor version 6 or newer, these fields are supported:
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_data_extent = 10;</code>
     * @return The hashTreeDataExtent.
     */
    @Override
    public Extent getHashTreeDataExtent() {
      return hashTreeDataExtent_ == null ? Extent.getDefaultInstance() : hashTreeDataExtent_;
    }
    /**
     * <pre>
     * On minor version 6 or newer, these fields are supported:
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_data_extent = 10;</code>
     */
    @Override
    public ExtentOrBuilder getHashTreeDataExtentOrBuilder() {
      return hashTreeDataExtent_ == null ? Extent.getDefaultInstance() : hashTreeDataExtent_;
    }

    public static final int HASH_TREE_EXTENT_FIELD_NUMBER = 11;
    private Extent hashTreeExtent_;
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_extent = 11;</code>
     * @return Whether the hashTreeExtent field is set.
     */
    @Override
    public boolean hasHashTreeExtent() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_extent = 11;</code>
     * @return The hashTreeExtent.
     */
    @Override
    public Extent getHashTreeExtent() {
      return hashTreeExtent_ == null ? Extent.getDefaultInstance() : hashTreeExtent_;
    }
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .Extent hash_tree_extent = 11;</code>
     */
    @Override
    public ExtentOrBuilder getHashTreeExtentOrBuilder() {
      return hashTreeExtent_ == null ? Extent.getDefaultInstance() : hashTreeExtent_;
    }

    public static final int HASH_TREE_ALGORITHM_FIELD_NUMBER = 12;
    private volatile Object hashTreeAlgorithm_;
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return Whether the hashTreeAlgorithm field is set.
     */
    @Override
    public boolean hasHashTreeAlgorithm() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The hashTreeAlgorithm.
     */
    @Override
    public String getHashTreeAlgorithm() {
      Object ref = hashTreeAlgorithm_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          hashTreeAlgorithm_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The bytes for hashTreeAlgorithm.
     */
    @Override
    public com.google.protobuf.ByteString
        getHashTreeAlgorithmBytes() {
      Object ref = hashTreeAlgorithm_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        hashTreeAlgorithm_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HASH_TREE_SALT_FIELD_NUMBER = 13;
    private com.google.protobuf.ByteString hashTreeSalt_;
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return Whether the hashTreeSalt field is set.
     */
    @Override
    public boolean hasHashTreeSalt() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return The hashTreeSalt.
     */
    @Override
    public com.google.protobuf.ByteString getHashTreeSalt() {
      return hashTreeSalt_;
    }

    public static final int FEC_DATA_EXTENT_FIELD_NUMBER = 14;
    private Extent fecDataExtent_;
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .Extent fec_data_extent = 14;</code>
     * @return Whether the fecDataExtent field is set.
     */
    @Override
    public boolean hasFecDataExtent() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .Extent fec_data_extent = 14;</code>
     * @return The fecDataExtent.
     */
    @Override
    public Extent getFecDataExtent() {
      return fecDataExtent_ == null ? Extent.getDefaultInstance() : fecDataExtent_;
    }
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .Extent fec_data_extent = 14;</code>
     */
    @Override
    public ExtentOrBuilder getFecDataExtentOrBuilder() {
      return fecDataExtent_ == null ? Extent.getDefaultInstance() : fecDataExtent_;
    }

    public static final int FEC_EXTENT_FIELD_NUMBER = 15;
    private Extent fecExtent_;
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .Extent fec_extent = 15;</code>
     * @return Whether the fecExtent field is set.
     */
    @Override
    public boolean hasFecExtent() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .Extent fec_extent = 15;</code>
     * @return The fecExtent.
     */
    @Override
    public Extent getFecExtent() {
      return fecExtent_ == null ? Extent.getDefaultInstance() : fecExtent_;
    }
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .Extent fec_extent = 15;</code>
     */
    @Override
    public ExtentOrBuilder getFecExtentOrBuilder() {
      return fecExtent_ == null ? Extent.getDefaultInstance() : fecExtent_;
    }

    public static final int FEC_ROOTS_FIELD_NUMBER = 16;
    private int fecRoots_;
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return Whether the fecRoots field is set.
     */
    @Override
    public boolean hasFecRoots() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return The fecRoots.
     */
    @Override
    public int getFecRoots() {
      return fecRoots_;
    }

    public static final int VERSION_FIELD_NUMBER = 17;
    private volatile Object version_;
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return Whether the version field is set.
     */
    @Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The version.
     */
    @Override
    public String getVersion() {
      Object ref = version_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The bytes for version.
     */
    @Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      Object ref = version_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MERGE_OPERATIONS_FIELD_NUMBER = 18;
    private java.util.List<CowMergeOperation> mergeOperations_;
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    @Override
    public java.util.List<CowMergeOperation> getMergeOperationsList() {
      return mergeOperations_;
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    @Override
    public java.util.List<? extends CowMergeOperationOrBuilder>
        getMergeOperationsOrBuilderList() {
      return mergeOperations_;
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    @Override
    public int getMergeOperationsCount() {
      return mergeOperations_.size();
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    @Override
    public CowMergeOperation getMergeOperations(int index) {
      return mergeOperations_.get(index);
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .CowMergeOperation merge_operations = 18;</code>
     */
    @Override
    public CowMergeOperationOrBuilder getMergeOperationsOrBuilder(
        int index) {
      return mergeOperations_.get(index);
    }

    public static final int ESTIMATE_COW_SIZE_FIELD_NUMBER = 19;
    private long estimateCowSize_;
    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return Whether the estimateCowSize field is set.
     */
    @Override
    public boolean hasEstimateCowSize() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return The estimateCowSize.
     */
    @Override
    public long getEstimateCowSize() {
      return estimateCowSize_;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasPartitionName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getOperationsCount(); i++) {
        if (!getOperations(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, partitionName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, runPostinstall_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, postinstallPath_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, filesystemType_);
      }
      for (int i = 0; i < newPartitionSignature_.size(); i++) {
        output.writeMessage(5, newPartitionSignature_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(6, getOldPartitionInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(7, getNewPartitionInfo());
      }
      for (int i = 0; i < operations_.size(); i++) {
        output.writeMessage(8, operations_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(9, postinstallOptional_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(10, getHashTreeDataExtent());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(11, getHashTreeExtent());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, hashTreeAlgorithm_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBytes(13, hashTreeSalt_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(14, getFecDataExtent());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeMessage(15, getFecExtent());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeUInt32(16, fecRoots_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 17, version_);
      }
      for (int i = 0; i < mergeOperations_.size(); i++) {
        output.writeMessage(18, mergeOperations_.get(i));
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeUInt64(19, estimateCowSize_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, partitionName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, runPostinstall_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, postinstallPath_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, filesystemType_);
      }
      for (int i = 0; i < newPartitionSignature_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, newPartitionSignature_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getOldPartitionInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getNewPartitionInfo());
      }
      for (int i = 0; i < operations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, operations_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, postinstallOptional_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getHashTreeDataExtent());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getHashTreeExtent());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, hashTreeAlgorithm_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(13, hashTreeSalt_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getFecDataExtent());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getFecExtent());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(16, fecRoots_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(17, version_);
      }
      for (int i = 0; i < mergeOperations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, mergeOperations_.get(i));
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(19, estimateCowSize_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof PartitionUpdate)) {
        return super.equals(obj);
      }
      PartitionUpdate other = (PartitionUpdate) obj;

      if (hasPartitionName() != other.hasPartitionName()) return false;
      if (hasPartitionName()) {
        if (!getPartitionName()
            .equals(other.getPartitionName())) return false;
      }
      if (hasRunPostinstall() != other.hasRunPostinstall()) return false;
      if (hasRunPostinstall()) {
        if (getRunPostinstall()
            != other.getRunPostinstall()) return false;
      }
      if (hasPostinstallPath() != other.hasPostinstallPath()) return false;
      if (hasPostinstallPath()) {
        if (!getPostinstallPath()
            .equals(other.getPostinstallPath())) return false;
      }
      if (hasFilesystemType() != other.hasFilesystemType()) return false;
      if (hasFilesystemType()) {
        if (!getFilesystemType()
            .equals(other.getFilesystemType())) return false;
      }
      if (!getNewPartitionSignatureList()
          .equals(other.getNewPartitionSignatureList())) return false;
      if (hasOldPartitionInfo() != other.hasOldPartitionInfo()) return false;
      if (hasOldPartitionInfo()) {
        if (!getOldPartitionInfo()
            .equals(other.getOldPartitionInfo())) return false;
      }
      if (hasNewPartitionInfo() != other.hasNewPartitionInfo()) return false;
      if (hasNewPartitionInfo()) {
        if (!getNewPartitionInfo()
            .equals(other.getNewPartitionInfo())) return false;
      }
      if (!getOperationsList()
          .equals(other.getOperationsList())) return false;
      if (hasPostinstallOptional() != other.hasPostinstallOptional()) return false;
      if (hasPostinstallOptional()) {
        if (getPostinstallOptional()
            != other.getPostinstallOptional()) return false;
      }
      if (hasHashTreeDataExtent() != other.hasHashTreeDataExtent()) return false;
      if (hasHashTreeDataExtent()) {
        if (!getHashTreeDataExtent()
            .equals(other.getHashTreeDataExtent())) return false;
      }
      if (hasHashTreeExtent() != other.hasHashTreeExtent()) return false;
      if (hasHashTreeExtent()) {
        if (!getHashTreeExtent()
            .equals(other.getHashTreeExtent())) return false;
      }
      if (hasHashTreeAlgorithm() != other.hasHashTreeAlgorithm()) return false;
      if (hasHashTreeAlgorithm()) {
        if (!getHashTreeAlgorithm()
            .equals(other.getHashTreeAlgorithm())) return false;
      }
      if (hasHashTreeSalt() != other.hasHashTreeSalt()) return false;
      if (hasHashTreeSalt()) {
        if (!getHashTreeSalt()
            .equals(other.getHashTreeSalt())) return false;
      }
      if (hasFecDataExtent() != other.hasFecDataExtent()) return false;
      if (hasFecDataExtent()) {
        if (!getFecDataExtent()
            .equals(other.getFecDataExtent())) return false;
      }
      if (hasFecExtent() != other.hasFecExtent()) return false;
      if (hasFecExtent()) {
        if (!getFecExtent()
            .equals(other.getFecExtent())) return false;
      }
      if (hasFecRoots() != other.hasFecRoots()) return false;
      if (hasFecRoots()) {
        if (getFecRoots()
            != other.getFecRoots()) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (!getMergeOperationsList()
          .equals(other.getMergeOperationsList())) return false;
      if (hasEstimateCowSize() != other.hasEstimateCowSize()) return false;
      if (hasEstimateCowSize()) {
        if (getEstimateCowSize()
            != other.getEstimateCowSize()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPartitionName()) {
        hash = (37 * hash) + PARTITION_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionName().hashCode();
      }
      if (hasRunPostinstall()) {
        hash = (37 * hash) + RUN_POSTINSTALL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRunPostinstall());
      }
      if (hasPostinstallPath()) {
        hash = (37 * hash) + POSTINSTALL_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getPostinstallPath().hashCode();
      }
      if (hasFilesystemType()) {
        hash = (37 * hash) + FILESYSTEM_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getFilesystemType().hashCode();
      }
      if (getNewPartitionSignatureCount() > 0) {
        hash = (37 * hash) + NEW_PARTITION_SIGNATURE_FIELD_NUMBER;
        hash = (53 * hash) + getNewPartitionSignatureList().hashCode();
      }
      if (hasOldPartitionInfo()) {
        hash = (37 * hash) + OLD_PARTITION_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldPartitionInfo().hashCode();
      }
      if (hasNewPartitionInfo()) {
        hash = (37 * hash) + NEW_PARTITION_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewPartitionInfo().hashCode();
      }
      if (getOperationsCount() > 0) {
        hash = (37 * hash) + OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getOperationsList().hashCode();
      }
      if (hasPostinstallOptional()) {
        hash = (37 * hash) + POSTINSTALL_OPTIONAL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPostinstallOptional());
      }
      if (hasHashTreeDataExtent()) {
        hash = (37 * hash) + HASH_TREE_DATA_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeDataExtent().hashCode();
      }
      if (hasHashTreeExtent()) {
        hash = (37 * hash) + HASH_TREE_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeExtent().hashCode();
      }
      if (hasHashTreeAlgorithm()) {
        hash = (37 * hash) + HASH_TREE_ALGORITHM_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeAlgorithm().hashCode();
      }
      if (hasHashTreeSalt()) {
        hash = (37 * hash) + HASH_TREE_SALT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeSalt().hashCode();
      }
      if (hasFecDataExtent()) {
        hash = (37 * hash) + FEC_DATA_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getFecDataExtent().hashCode();
      }
      if (hasFecExtent()) {
        hash = (37 * hash) + FEC_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getFecExtent().hashCode();
      }
      if (hasFecRoots()) {
        hash = (37 * hash) + FEC_ROOTS_FIELD_NUMBER;
        hash = (53 * hash) + getFecRoots();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      if (getMergeOperationsCount() > 0) {
        hash = (37 * hash) + MERGE_OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMergeOperationsList().hashCode();
      }
      if (hasEstimateCowSize()) {
        hash = (37 * hash) + ESTIMATE_COW_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getEstimateCowSize());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static PartitionUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static PartitionUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static PartitionUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static PartitionUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static PartitionUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static PartitionUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static PartitionUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static PartitionUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static PartitionUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static PartitionUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static PartitionUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static PartitionUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(PartitionUpdate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes the update to apply to a single partition.
     * </pre>
     *
     * Protobuf type {@code PartitionUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:PartitionUpdate)
        PartitionUpdateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                PartitionUpdate.class, Builder.class);
      }

      // Construct using UpdateMetadata.PartitionUpdate.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getNewPartitionSignatureFieldBuilder();
          getOldPartitionInfoFieldBuilder();
          getNewPartitionInfoFieldBuilder();
          getOperationsFieldBuilder();
          getHashTreeDataExtentFieldBuilder();
          getHashTreeExtentFieldBuilder();
          getFecDataExtentFieldBuilder();
          getFecExtentFieldBuilder();
          getMergeOperationsFieldBuilder();
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        partitionName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        runPostinstall_ = false;
        bitField0_ = (bitField0_ & ~0x00000002);
        postinstallPath_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        filesystemType_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignature_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          newPartitionSignatureBuilder_.clear();
        }
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfo_ = null;
        } else {
          oldPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfo_ = null;
        } else {
          newPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        if (operationsBuilder_ == null) {
          operations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
        } else {
          operationsBuilder_.clear();
        }
        postinstallOptional_ = false;
        bitField0_ = (bitField0_ & ~0x00000100);
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtent_ = null;
        } else {
          hashTreeDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtent_ = null;
        } else {
          hashTreeExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        hashTreeAlgorithm_ = "";
        bitField0_ = (bitField0_ & ~0x00000800);
        hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00001000);
        if (fecDataExtentBuilder_ == null) {
          fecDataExtent_ = null;
        } else {
          fecDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        if (fecExtentBuilder_ == null) {
          fecExtent_ = null;
        } else {
          fecExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        fecRoots_ = 2;
        bitField0_ = (bitField0_ & ~0x00008000);
        version_ = "";
        bitField0_ = (bitField0_ & ~0x00010000);
        if (mergeOperationsBuilder_ == null) {
          mergeOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00020000);
        } else {
          mergeOperationsBuilder_.clear();
        }
        estimateCowSize_ = 0L;
        bitField0_ = (bitField0_ & ~0x00040000);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
      }

      @Override
      public PartitionUpdate getDefaultInstanceForType() {
        return PartitionUpdate.getDefaultInstance();
      }

      @Override
      public PartitionUpdate build() {
        PartitionUpdate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public PartitionUpdate buildPartial() {
        PartitionUpdate result = new PartitionUpdate(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.partitionName_ = partitionName_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.runPostinstall_ = runPostinstall_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.postinstallPath_ = postinstallPath_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.filesystemType_ = filesystemType_;
        if (newPartitionSignatureBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            newPartitionSignature_ = java.util.Collections.unmodifiableList(newPartitionSignature_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.newPartitionSignature_ = newPartitionSignature_;
        } else {
          result.newPartitionSignature_ = newPartitionSignatureBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          if (oldPartitionInfoBuilder_ == null) {
            result.oldPartitionInfo_ = oldPartitionInfo_;
          } else {
            result.oldPartitionInfo_ = oldPartitionInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          if (newPartitionInfoBuilder_ == null) {
            result.newPartitionInfo_ = newPartitionInfo_;
          } else {
            result.newPartitionInfo_ = newPartitionInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000020;
        }
        if (operationsBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            operations_ = java.util.Collections.unmodifiableList(operations_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.operations_ = operations_;
        } else {
          result.operations_ = operationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.postinstallOptional_ = postinstallOptional_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          if (hashTreeDataExtentBuilder_ == null) {
            result.hashTreeDataExtent_ = hashTreeDataExtent_;
          } else {
            result.hashTreeDataExtent_ = hashTreeDataExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          if (hashTreeExtentBuilder_ == null) {
            result.hashTreeExtent_ = hashTreeExtent_;
          } else {
            result.hashTreeExtent_ = hashTreeExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          to_bitField0_ |= 0x00000200;
        }
        result.hashTreeAlgorithm_ = hashTreeAlgorithm_;
        if (((from_bitField0_ & 0x00001000) != 0)) {
          to_bitField0_ |= 0x00000400;
        }
        result.hashTreeSalt_ = hashTreeSalt_;
        if (((from_bitField0_ & 0x00002000) != 0)) {
          if (fecDataExtentBuilder_ == null) {
            result.fecDataExtent_ = fecDataExtent_;
          } else {
            result.fecDataExtent_ = fecDataExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          if (fecExtentBuilder_ == null) {
            result.fecExtent_ = fecExtent_;
          } else {
            result.fecExtent_ = fecExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          to_bitField0_ |= 0x00002000;
        }
        result.fecRoots_ = fecRoots_;
        if (((from_bitField0_ & 0x00010000) != 0)) {
          to_bitField0_ |= 0x00004000;
        }
        result.version_ = version_;
        if (mergeOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00020000) != 0)) {
            mergeOperations_ = java.util.Collections.unmodifiableList(mergeOperations_);
            bitField0_ = (bitField0_ & ~0x00020000);
          }
          result.mergeOperations_ = mergeOperations_;
        } else {
          result.mergeOperations_ = mergeOperationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.estimateCowSize_ = estimateCowSize_;
          to_bitField0_ |= 0x00008000;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof PartitionUpdate) {
          return mergeFrom((PartitionUpdate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(PartitionUpdate other) {
        if (other == PartitionUpdate.getDefaultInstance()) return this;
        if (other.hasPartitionName()) {
          bitField0_ |= 0x00000001;
          partitionName_ = other.partitionName_;
          onChanged();
        }
        if (other.hasRunPostinstall()) {
          setRunPostinstall(other.getRunPostinstall());
        }
        if (other.hasPostinstallPath()) {
          bitField0_ |= 0x00000004;
          postinstallPath_ = other.postinstallPath_;
          onChanged();
        }
        if (other.hasFilesystemType()) {
          bitField0_ |= 0x00000008;
          filesystemType_ = other.filesystemType_;
          onChanged();
        }
        if (newPartitionSignatureBuilder_ == null) {
          if (!other.newPartitionSignature_.isEmpty()) {
            if (newPartitionSignature_.isEmpty()) {
              newPartitionSignature_ = other.newPartitionSignature_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureNewPartitionSignatureIsMutable();
              newPartitionSignature_.addAll(other.newPartitionSignature_);
            }
            onChanged();
          }
        } else {
          if (!other.newPartitionSignature_.isEmpty()) {
            if (newPartitionSignatureBuilder_.isEmpty()) {
              newPartitionSignatureBuilder_.dispose();
              newPartitionSignatureBuilder_ = null;
              newPartitionSignature_ = other.newPartitionSignature_;
              bitField0_ = (bitField0_ & ~0x00000010);
              newPartitionSignatureBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getNewPartitionSignatureFieldBuilder() : null;
            } else {
              newPartitionSignatureBuilder_.addAllMessages(other.newPartitionSignature_);
            }
          }
        }
        if (other.hasOldPartitionInfo()) {
          mergeOldPartitionInfo(other.getOldPartitionInfo());
        }
        if (other.hasNewPartitionInfo()) {
          mergeNewPartitionInfo(other.getNewPartitionInfo());
        }
        if (operationsBuilder_ == null) {
          if (!other.operations_.isEmpty()) {
            if (operations_.isEmpty()) {
              operations_ = other.operations_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureOperationsIsMutable();
              operations_.addAll(other.operations_);
            }
            onChanged();
          }
        } else {
          if (!other.operations_.isEmpty()) {
            if (operationsBuilder_.isEmpty()) {
              operationsBuilder_.dispose();
              operationsBuilder_ = null;
              operations_ = other.operations_;
              bitField0_ = (bitField0_ & ~0x00000080);
              operationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getOperationsFieldBuilder() : null;
            } else {
              operationsBuilder_.addAllMessages(other.operations_);
            }
          }
        }
        if (other.hasPostinstallOptional()) {
          setPostinstallOptional(other.getPostinstallOptional());
        }
        if (other.hasHashTreeDataExtent()) {
          mergeHashTreeDataExtent(other.getHashTreeDataExtent());
        }
        if (other.hasHashTreeExtent()) {
          mergeHashTreeExtent(other.getHashTreeExtent());
        }
        if (other.hasHashTreeAlgorithm()) {
          bitField0_ |= 0x00000800;
          hashTreeAlgorithm_ = other.hashTreeAlgorithm_;
          onChanged();
        }
        if (other.hasHashTreeSalt()) {
          setHashTreeSalt(other.getHashTreeSalt());
        }
        if (other.hasFecDataExtent()) {
          mergeFecDataExtent(other.getFecDataExtent());
        }
        if (other.hasFecExtent()) {
          mergeFecExtent(other.getFecExtent());
        }
        if (other.hasFecRoots()) {
          setFecRoots(other.getFecRoots());
        }
        if (other.hasVersion()) {
          bitField0_ |= 0x00010000;
          version_ = other.version_;
          onChanged();
        }
        if (mergeOperationsBuilder_ == null) {
          if (!other.mergeOperations_.isEmpty()) {
            if (mergeOperations_.isEmpty()) {
              mergeOperations_ = other.mergeOperations_;
              bitField0_ = (bitField0_ & ~0x00020000);
            } else {
              ensureMergeOperationsIsMutable();
              mergeOperations_.addAll(other.mergeOperations_);
            }
            onChanged();
          }
        } else {
          if (!other.mergeOperations_.isEmpty()) {
            if (mergeOperationsBuilder_.isEmpty()) {
              mergeOperationsBuilder_.dispose();
              mergeOperationsBuilder_ = null;
              mergeOperations_ = other.mergeOperations_;
              bitField0_ = (bitField0_ & ~0x00020000);
              mergeOperationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMergeOperationsFieldBuilder() : null;
            } else {
              mergeOperationsBuilder_.addAllMessages(other.mergeOperations_);
            }
          }
        }
        if (other.hasEstimateCowSize()) {
          setEstimateCowSize(other.getEstimateCowSize());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        if (!hasPartitionName()) {
          return false;
        }
        for (int i = 0; i < getOperationsCount(); i++) {
          if (!getOperations(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        PartitionUpdate parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (PartitionUpdate) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object partitionName_ = "";
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return Whether the partitionName field is set.
       */
      public boolean hasPartitionName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return The partitionName.
       */
      public String getPartitionName() {
        Object ref = partitionName_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            partitionName_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return The bytes for partitionName.
       */
      public com.google.protobuf.ByteString
          getPartitionNameBytes() {
        Object ref = partitionName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          partitionName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @param value The partitionName to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionName(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        partitionName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartitionName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        partitionName_ = getDefaultInstance().getPartitionName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @param value The bytes for partitionName to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        partitionName_ = value;
        onChanged();
        return this;
      }

      private boolean runPostinstall_ ;
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return Whether the runPostinstall field is set.
       */
      @Override
      public boolean hasRunPostinstall() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return The runPostinstall.
       */
      @Override
      public boolean getRunPostinstall() {
        return runPostinstall_;
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @param value The runPostinstall to set.
       * @return This builder for chaining.
       */
      public Builder setRunPostinstall(boolean value) {
        bitField0_ |= 0x00000002;
        runPostinstall_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRunPostinstall() {
        bitField0_ = (bitField0_ & ~0x00000002);
        runPostinstall_ = false;
        onChanged();
        return this;
      }

      private Object postinstallPath_ = "";
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return Whether the postinstallPath field is set.
       */
      public boolean hasPostinstallPath() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return The postinstallPath.
       */
      public String getPostinstallPath() {
        Object ref = postinstallPath_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            postinstallPath_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return The bytes for postinstallPath.
       */
      public com.google.protobuf.ByteString
          getPostinstallPathBytes() {
        Object ref = postinstallPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          postinstallPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @param value The postinstallPath to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallPath(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        postinstallPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPostinstallPath() {
        bitField0_ = (bitField0_ & ~0x00000004);
        postinstallPath_ = getDefaultInstance().getPostinstallPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @param value The bytes for postinstallPath to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        postinstallPath_ = value;
        onChanged();
        return this;
      }

      private Object filesystemType_ = "";
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return Whether the filesystemType field is set.
       */
      public boolean hasFilesystemType() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return The filesystemType.
       */
      public String getFilesystemType() {
        Object ref = filesystemType_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            filesystemType_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return The bytes for filesystemType.
       */
      public com.google.protobuf.ByteString
          getFilesystemTypeBytes() {
        Object ref = filesystemType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          filesystemType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @param value The filesystemType to set.
       * @return This builder for chaining.
       */
      public Builder setFilesystemType(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        filesystemType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFilesystemType() {
        bitField0_ = (bitField0_ & ~0x00000008);
        filesystemType_ = getDefaultInstance().getFilesystemType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @param value The bytes for filesystemType to set.
       * @return This builder for chaining.
       */
      public Builder setFilesystemTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        filesystemType_ = value;
        onChanged();
        return this;
      }

      private java.util.List<Signatures.Signature> newPartitionSignature_ =
        java.util.Collections.emptyList();
      private void ensureNewPartitionSignatureIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          newPartitionSignature_ = new java.util.ArrayList<Signatures.Signature>(newPartitionSignature_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          Signatures.Signature, Signatures.Signature.Builder, Signatures.SignatureOrBuilder> newPartitionSignatureBuilder_;

      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<Signatures.Signature> getNewPartitionSignatureList() {
        if (newPartitionSignatureBuilder_ == null) {
          return java.util.Collections.unmodifiableList(newPartitionSignature_);
        } else {
          return newPartitionSignatureBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public int getNewPartitionSignatureCount() {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.size();
        } else {
          return newPartitionSignatureBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Signatures.Signature getNewPartitionSignature(int index) {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.get(index);
        } else {
          return newPartitionSignatureBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder setNewPartitionSignature(
          int index, Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.set(index, value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder setNewPartitionSignature(
          int index, Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.set(index, builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          int index, Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(index, value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          int index, Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(index, builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addAllNewPartitionSignature(
          Iterable<? extends Signatures.Signature> values) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, newPartitionSignature_);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder clearNewPartitionSignature() {
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignature_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder removeNewPartitionSignature(int index) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.remove(index);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Signatures.Signature.Builder getNewPartitionSignatureBuilder(
          int index) {
        return getNewPartitionSignatureFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
          int index) {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.get(index);  } else {
          return newPartitionSignatureBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<? extends Signatures.SignatureOrBuilder>
           getNewPartitionSignatureOrBuilderList() {
        if (newPartitionSignatureBuilder_ != null) {
          return newPartitionSignatureBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(newPartitionSignature_);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Signatures.Signature.Builder addNewPartitionSignatureBuilder() {
        return getNewPartitionSignatureFieldBuilder().addBuilder(
            Signatures.Signature.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public Signatures.Signature.Builder addNewPartitionSignatureBuilder(
          int index) {
        return getNewPartitionSignatureFieldBuilder().addBuilder(
            index, Signatures.Signature.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<Signatures.Signature.Builder>
           getNewPartitionSignatureBuilderList() {
        return getNewPartitionSignatureFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          Signatures.Signature, Signatures.Signature.Builder, Signatures.SignatureOrBuilder>
          getNewPartitionSignatureFieldBuilder() {
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignatureBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              Signatures.Signature, Signatures.Signature.Builder, Signatures.SignatureOrBuilder>(
                  newPartitionSignature_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          newPartitionSignature_ = null;
        }
        return newPartitionSignatureBuilder_;
      }

      private PartitionInfo oldPartitionInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder> oldPartitionInfoBuilder_;
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       * @return Whether the oldPartitionInfo field is set.
       */
      public boolean hasOldPartitionInfo() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       * @return The oldPartitionInfo.
       */
      public PartitionInfo getOldPartitionInfo() {
        if (oldPartitionInfoBuilder_ == null) {
          return oldPartitionInfo_ == null ? PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
        } else {
          return oldPartitionInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       */
      public Builder setOldPartitionInfo(PartitionInfo value) {
        if (oldPartitionInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldPartitionInfo_ = value;
          onChanged();
        } else {
          oldPartitionInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       */
      public Builder setOldPartitionInfo(
          PartitionInfo.Builder builderForValue) {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldPartitionInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       */
      public Builder mergeOldPartitionInfo(PartitionInfo value) {
        if (oldPartitionInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
              oldPartitionInfo_ != null &&
              oldPartitionInfo_ != PartitionInfo.getDefaultInstance()) {
            oldPartitionInfo_ =
              PartitionInfo.newBuilder(oldPartitionInfo_).mergeFrom(value).buildPartial();
          } else {
            oldPartitionInfo_ = value;
          }
          onChanged();
        } else {
          oldPartitionInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       */
      public Builder clearOldPartitionInfo() {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfo_ = null;
          onChanged();
        } else {
          oldPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       */
      public PartitionInfo.Builder getOldPartitionInfoBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getOldPartitionInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       */
      public PartitionInfoOrBuilder getOldPartitionInfoOrBuilder() {
        if (oldPartitionInfoBuilder_ != null) {
          return oldPartitionInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldPartitionInfo_ == null ?
              PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
        }
      }
      /**
       * <code>optional .PartitionInfo old_partition_info = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>
          getOldPartitionInfoFieldBuilder() {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>(
                  getOldPartitionInfo(),
                  getParentForChildren(),
                  isClean());
          oldPartitionInfo_ = null;
        }
        return oldPartitionInfoBuilder_;
      }

      private PartitionInfo newPartitionInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder> newPartitionInfoBuilder_;
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       * @return Whether the newPartitionInfo field is set.
       */
      public boolean hasNewPartitionInfo() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       * @return The newPartitionInfo.
       */
      public PartitionInfo getNewPartitionInfo() {
        if (newPartitionInfoBuilder_ == null) {
          return newPartitionInfo_ == null ? PartitionInfo.getDefaultInstance() : newPartitionInfo_;
        } else {
          return newPartitionInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       */
      public Builder setNewPartitionInfo(PartitionInfo value) {
        if (newPartitionInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newPartitionInfo_ = value;
          onChanged();
        } else {
          newPartitionInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       */
      public Builder setNewPartitionInfo(
          PartitionInfo.Builder builderForValue) {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfo_ = builderForValue.build();
          onChanged();
        } else {
          newPartitionInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       */
      public Builder mergeNewPartitionInfo(PartitionInfo value) {
        if (newPartitionInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
              newPartitionInfo_ != null &&
              newPartitionInfo_ != PartitionInfo.getDefaultInstance()) {
            newPartitionInfo_ =
              PartitionInfo.newBuilder(newPartitionInfo_).mergeFrom(value).buildPartial();
          } else {
            newPartitionInfo_ = value;
          }
          onChanged();
        } else {
          newPartitionInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       */
      public Builder clearNewPartitionInfo() {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfo_ = null;
          onChanged();
        } else {
          newPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       */
      public PartitionInfo.Builder getNewPartitionInfoBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getNewPartitionInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       */
      public PartitionInfoOrBuilder getNewPartitionInfoOrBuilder() {
        if (newPartitionInfoBuilder_ != null) {
          return newPartitionInfoBuilder_.getMessageOrBuilder();
        } else {
          return newPartitionInfo_ == null ?
              PartitionInfo.getDefaultInstance() : newPartitionInfo_;
        }
      }
      /**
       * <code>optional .PartitionInfo new_partition_info = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>
          getNewPartitionInfoFieldBuilder() {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>(
                  getNewPartitionInfo(),
                  getParentForChildren(),
                  isClean());
          newPartitionInfo_ = null;
        }
        return newPartitionInfoBuilder_;
      }

      private java.util.List<InstallOperation> operations_ =
        java.util.Collections.emptyList();
      private void ensureOperationsIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          operations_ = new java.util.ArrayList<InstallOperation>(operations_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder> operationsBuilder_;

      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public java.util.List<InstallOperation> getOperationsList() {
        if (operationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(operations_);
        } else {
          return operationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public int getOperationsCount() {
        if (operationsBuilder_ == null) {
          return operations_.size();
        } else {
          return operationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public InstallOperation getOperations(int index) {
        if (operationsBuilder_ == null) {
          return operations_.get(index);
        } else {
          return operationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder setOperations(
          int index, InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.set(index, value);
          onChanged();
        } else {
          operationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder setOperations(
          int index, InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.set(index, builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder addOperations(InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.add(value);
          onChanged();
        } else {
          operationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          int index, InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.add(index, value);
          onChanged();
        } else {
          operationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.add(builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          int index, InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.add(index, builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder addAllOperations(
          Iterable<? extends InstallOperation> values) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, operations_);
          onChanged();
        } else {
          operationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder clearOperations() {
        if (operationsBuilder_ == null) {
          operations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          operationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public Builder removeOperations(int index) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.remove(index);
          onChanged();
        } else {
          operationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public InstallOperation.Builder getOperationsBuilder(
          int index) {
        return getOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public InstallOperationOrBuilder getOperationsOrBuilder(
          int index) {
        if (operationsBuilder_ == null) {
          return operations_.get(index);  } else {
          return operationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public java.util.List<? extends InstallOperationOrBuilder>
           getOperationsOrBuilderList() {
        if (operationsBuilder_ != null) {
          return operationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(operations_);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public InstallOperation.Builder addOperationsBuilder() {
        return getOperationsFieldBuilder().addBuilder(
            InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public InstallOperation.Builder addOperationsBuilder(
          int index) {
        return getOperationsFieldBuilder().addBuilder(
            index, InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .InstallOperation operations = 8;</code>
       */
      public java.util.List<InstallOperation.Builder>
           getOperationsBuilderList() {
        return getOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder>
          getOperationsFieldBuilder() {
        if (operationsBuilder_ == null) {
          operationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder>(
                  operations_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          operations_ = null;
        }
        return operationsBuilder_;
      }

      private boolean postinstallOptional_ ;
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return Whether the postinstallOptional field is set.
       */
      @Override
      public boolean hasPostinstallOptional() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return The postinstallOptional.
       */
      @Override
      public boolean getPostinstallOptional() {
        return postinstallOptional_;
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @param value The postinstallOptional to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallOptional(boolean value) {
        bitField0_ |= 0x00000100;
        postinstallOptional_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearPostinstallOptional() {
        bitField0_ = (bitField0_ & ~0x00000100);
        postinstallOptional_ = false;
        onChanged();
        return this;
      }

      private Extent hashTreeDataExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> hashTreeDataExtentBuilder_;
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       * @return Whether the hashTreeDataExtent field is set.
       */
      public boolean hasHashTreeDataExtent() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       * @return The hashTreeDataExtent.
       */
      public Extent getHashTreeDataExtent() {
        if (hashTreeDataExtentBuilder_ == null) {
          return hashTreeDataExtent_ == null ? Extent.getDefaultInstance() : hashTreeDataExtent_;
        } else {
          return hashTreeDataExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       */
      public Builder setHashTreeDataExtent(Extent value) {
        if (hashTreeDataExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hashTreeDataExtent_ = value;
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       */
      public Builder setHashTreeDataExtent(
          Extent.Builder builderForValue) {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtent_ = builderForValue.build();
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       */
      public Builder mergeHashTreeDataExtent(Extent value) {
        if (hashTreeDataExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
              hashTreeDataExtent_ != null &&
              hashTreeDataExtent_ != Extent.getDefaultInstance()) {
            hashTreeDataExtent_ =
              Extent.newBuilder(hashTreeDataExtent_).mergeFrom(value).buildPartial();
          } else {
            hashTreeDataExtent_ = value;
          }
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       */
      public Builder clearHashTreeDataExtent() {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtent_ = null;
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       */
      public Extent.Builder getHashTreeDataExtentBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getHashTreeDataExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       */
      public ExtentOrBuilder getHashTreeDataExtentOrBuilder() {
        if (hashTreeDataExtentBuilder_ != null) {
          return hashTreeDataExtentBuilder_.getMessageOrBuilder();
        } else {
          return hashTreeDataExtent_ == null ?
              Extent.getDefaultInstance() : hashTreeDataExtent_;
        }
      }
      /**
       * <pre>
       * On minor version 6 or newer, these fields are supported:
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_data_extent = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getHashTreeDataExtentFieldBuilder() {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  getHashTreeDataExtent(),
                  getParentForChildren(),
                  isClean());
          hashTreeDataExtent_ = null;
        }
        return hashTreeDataExtentBuilder_;
      }

      private Extent hashTreeExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> hashTreeExtentBuilder_;
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       * @return Whether the hashTreeExtent field is set.
       */
      public boolean hasHashTreeExtent() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       * @return The hashTreeExtent.
       */
      public Extent getHashTreeExtent() {
        if (hashTreeExtentBuilder_ == null) {
          return hashTreeExtent_ == null ? Extent.getDefaultInstance() : hashTreeExtent_;
        } else {
          return hashTreeExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       */
      public Builder setHashTreeExtent(Extent value) {
        if (hashTreeExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hashTreeExtent_ = value;
          onChanged();
        } else {
          hashTreeExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       */
      public Builder setHashTreeExtent(
          Extent.Builder builderForValue) {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtent_ = builderForValue.build();
          onChanged();
        } else {
          hashTreeExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       */
      public Builder mergeHashTreeExtent(Extent value) {
        if (hashTreeExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
              hashTreeExtent_ != null &&
              hashTreeExtent_ != Extent.getDefaultInstance()) {
            hashTreeExtent_ =
              Extent.newBuilder(hashTreeExtent_).mergeFrom(value).buildPartial();
          } else {
            hashTreeExtent_ = value;
          }
          onChanged();
        } else {
          hashTreeExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       */
      public Builder clearHashTreeExtent() {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtent_ = null;
          onChanged();
        } else {
          hashTreeExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       */
      public Extent.Builder getHashTreeExtentBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getHashTreeExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       */
      public ExtentOrBuilder getHashTreeExtentOrBuilder() {
        if (hashTreeExtentBuilder_ != null) {
          return hashTreeExtentBuilder_.getMessageOrBuilder();
        } else {
          return hashTreeExtent_ == null ?
              Extent.getDefaultInstance() : hashTreeExtent_;
        }
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .Extent hash_tree_extent = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getHashTreeExtentFieldBuilder() {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  getHashTreeExtent(),
                  getParentForChildren(),
                  isClean());
          hashTreeExtent_ = null;
        }
        return hashTreeExtentBuilder_;
      }

      private Object hashTreeAlgorithm_ = "";
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return Whether the hashTreeAlgorithm field is set.
       */
      public boolean hasHashTreeAlgorithm() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return The hashTreeAlgorithm.
       */
      public String getHashTreeAlgorithm() {
        Object ref = hashTreeAlgorithm_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            hashTreeAlgorithm_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return The bytes for hashTreeAlgorithm.
       */
      public com.google.protobuf.ByteString
          getHashTreeAlgorithmBytes() {
        Object ref = hashTreeAlgorithm_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          hashTreeAlgorithm_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @param value The hashTreeAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeAlgorithm(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000800;
        hashTreeAlgorithm_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashTreeAlgorithm() {
        bitField0_ = (bitField0_ & ~0x00000800);
        hashTreeAlgorithm_ = getDefaultInstance().getHashTreeAlgorithm();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @param value The bytes for hashTreeAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeAlgorithmBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000800;
        hashTreeAlgorithm_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return Whether the hashTreeSalt field is set.
       */
      @Override
      public boolean hasHashTreeSalt() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return The hashTreeSalt.
       */
      @Override
      public com.google.protobuf.ByteString getHashTreeSalt() {
        return hashTreeSalt_;
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @param value The hashTreeSalt to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeSalt(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00001000;
        hashTreeSalt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashTreeSalt() {
        bitField0_ = (bitField0_ & ~0x00001000);
        hashTreeSalt_ = getDefaultInstance().getHashTreeSalt();
        onChanged();
        return this;
      }

      private Extent fecDataExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> fecDataExtentBuilder_;
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       * @return Whether the fecDataExtent field is set.
       */
      public boolean hasFecDataExtent() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       * @return The fecDataExtent.
       */
      public Extent getFecDataExtent() {
        if (fecDataExtentBuilder_ == null) {
          return fecDataExtent_ == null ? Extent.getDefaultInstance() : fecDataExtent_;
        } else {
          return fecDataExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       */
      public Builder setFecDataExtent(Extent value) {
        if (fecDataExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fecDataExtent_ = value;
          onChanged();
        } else {
          fecDataExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       */
      public Builder setFecDataExtent(
          Extent.Builder builderForValue) {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtent_ = builderForValue.build();
          onChanged();
        } else {
          fecDataExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       */
      public Builder mergeFecDataExtent(Extent value) {
        if (fecDataExtentBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
              fecDataExtent_ != null &&
              fecDataExtent_ != Extent.getDefaultInstance()) {
            fecDataExtent_ =
              Extent.newBuilder(fecDataExtent_).mergeFrom(value).buildPartial();
          } else {
            fecDataExtent_ = value;
          }
          onChanged();
        } else {
          fecDataExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       */
      public Builder clearFecDataExtent() {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtent_ = null;
          onChanged();
        } else {
          fecDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       */
      public Extent.Builder getFecDataExtentBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getFecDataExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       */
      public ExtentOrBuilder getFecDataExtentOrBuilder() {
        if (fecDataExtentBuilder_ != null) {
          return fecDataExtentBuilder_.getMessageOrBuilder();
        } else {
          return fecDataExtent_ == null ?
              Extent.getDefaultInstance() : fecDataExtent_;
        }
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .Extent fec_data_extent = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getFecDataExtentFieldBuilder() {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  getFecDataExtent(),
                  getParentForChildren(),
                  isClean());
          fecDataExtent_ = null;
        }
        return fecDataExtentBuilder_;
      }

      private Extent fecExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder> fecExtentBuilder_;
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       * @return Whether the fecExtent field is set.
       */
      public boolean hasFecExtent() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       * @return The fecExtent.
       */
      public Extent getFecExtent() {
        if (fecExtentBuilder_ == null) {
          return fecExtent_ == null ? Extent.getDefaultInstance() : fecExtent_;
        } else {
          return fecExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       */
      public Builder setFecExtent(Extent value) {
        if (fecExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fecExtent_ = value;
          onChanged();
        } else {
          fecExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       */
      public Builder setFecExtent(
          Extent.Builder builderForValue) {
        if (fecExtentBuilder_ == null) {
          fecExtent_ = builderForValue.build();
          onChanged();
        } else {
          fecExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       */
      public Builder mergeFecExtent(Extent value) {
        if (fecExtentBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0) &&
              fecExtent_ != null &&
              fecExtent_ != Extent.getDefaultInstance()) {
            fecExtent_ =
              Extent.newBuilder(fecExtent_).mergeFrom(value).buildPartial();
          } else {
            fecExtent_ = value;
          }
          onChanged();
        } else {
          fecExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       */
      public Builder clearFecExtent() {
        if (fecExtentBuilder_ == null) {
          fecExtent_ = null;
          onChanged();
        } else {
          fecExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       */
      public Extent.Builder getFecExtentBuilder() {
        bitField0_ |= 0x00004000;
        onChanged();
        return getFecExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       */
      public ExtentOrBuilder getFecExtentOrBuilder() {
        if (fecExtentBuilder_ != null) {
          return fecExtentBuilder_.getMessageOrBuilder();
        } else {
          return fecExtent_ == null ?
              Extent.getDefaultInstance() : fecExtent_;
        }
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .Extent fec_extent = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          Extent, Extent.Builder, ExtentOrBuilder>
          getFecExtentFieldBuilder() {
        if (fecExtentBuilder_ == null) {
          fecExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              Extent, Extent.Builder, ExtentOrBuilder>(
                  getFecExtent(),
                  getParentForChildren(),
                  isClean());
          fecExtent_ = null;
        }
        return fecExtentBuilder_;
      }

      private int fecRoots_ = 2;
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return Whether the fecRoots field is set.
       */
      @Override
      public boolean hasFecRoots() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return The fecRoots.
       */
      @Override
      public int getFecRoots() {
        return fecRoots_;
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @param value The fecRoots to set.
       * @return This builder for chaining.
       */
      public Builder setFecRoots(int value) {
        bitField0_ |= 0x00008000;
        fecRoots_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return This builder for chaining.
       */
      public Builder clearFecRoots() {
        bitField0_ = (bitField0_ & ~0x00008000);
        fecRoots_ = 2;
        onChanged();
        return this;
      }

      private Object version_ = "";
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return The version.
       */
      public String getVersion() {
        Object ref = version_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00010000;
        version_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00010000);
        version_ = getDefaultInstance().getVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00010000;
        version_ = value;
        onChanged();
        return this;
      }

      private java.util.List<CowMergeOperation> mergeOperations_ =
        java.util.Collections.emptyList();
      private void ensureMergeOperationsIsMutable() {
        if (!((bitField0_ & 0x00020000) != 0)) {
          mergeOperations_ = new java.util.ArrayList<CowMergeOperation>(mergeOperations_);
          bitField0_ |= 0x00020000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          CowMergeOperation, CowMergeOperation.Builder, CowMergeOperationOrBuilder> mergeOperationsBuilder_;

      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public java.util.List<CowMergeOperation> getMergeOperationsList() {
        if (mergeOperationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(mergeOperations_);
        } else {
          return mergeOperationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public int getMergeOperationsCount() {
        if (mergeOperationsBuilder_ == null) {
          return mergeOperations_.size();
        } else {
          return mergeOperationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public CowMergeOperation getMergeOperations(int index) {
        if (mergeOperationsBuilder_ == null) {
          return mergeOperations_.get(index);
        } else {
          return mergeOperationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder setMergeOperations(
          int index, CowMergeOperation value) {
        if (mergeOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMergeOperationsIsMutable();
          mergeOperations_.set(index, value);
          onChanged();
        } else {
          mergeOperationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder setMergeOperations(
          int index, CowMergeOperation.Builder builderForValue) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.set(index, builderForValue.build());
          onChanged();
        } else {
          mergeOperationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(CowMergeOperation value) {
        if (mergeOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(value);
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(
          int index, CowMergeOperation value) {
        if (mergeOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(index, value);
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(
          CowMergeOperation.Builder builderForValue) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(builderForValue.build());
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(
          int index, CowMergeOperation.Builder builderForValue) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(index, builderForValue.build());
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addAllMergeOperations(
          Iterable<? extends CowMergeOperation> values) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, mergeOperations_);
          onChanged();
        } else {
          mergeOperationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder clearMergeOperations() {
        if (mergeOperationsBuilder_ == null) {
          mergeOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00020000);
          onChanged();
        } else {
          mergeOperationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public Builder removeMergeOperations(int index) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.remove(index);
          onChanged();
        } else {
          mergeOperationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public CowMergeOperation.Builder getMergeOperationsBuilder(
          int index) {
        return getMergeOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public CowMergeOperationOrBuilder getMergeOperationsOrBuilder(
          int index) {
        if (mergeOperationsBuilder_ == null) {
          return mergeOperations_.get(index);  } else {
          return mergeOperationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public java.util.List<? extends CowMergeOperationOrBuilder>
           getMergeOperationsOrBuilderList() {
        if (mergeOperationsBuilder_ != null) {
          return mergeOperationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(mergeOperations_);
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public CowMergeOperation.Builder addMergeOperationsBuilder() {
        return getMergeOperationsFieldBuilder().addBuilder(
            CowMergeOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public CowMergeOperation.Builder addMergeOperationsBuilder(
          int index) {
        return getMergeOperationsFieldBuilder().addBuilder(
            index, CowMergeOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .CowMergeOperation merge_operations = 18;</code>
       */
      public java.util.List<CowMergeOperation.Builder>
           getMergeOperationsBuilderList() {
        return getMergeOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          CowMergeOperation, CowMergeOperation.Builder, CowMergeOperationOrBuilder>
          getMergeOperationsFieldBuilder() {
        if (mergeOperationsBuilder_ == null) {
          mergeOperationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              CowMergeOperation, CowMergeOperation.Builder, CowMergeOperationOrBuilder>(
                  mergeOperations_,
                  ((bitField0_ & 0x00020000) != 0),
                  getParentForChildren(),
                  isClean());
          mergeOperations_ = null;
        }
        return mergeOperationsBuilder_;
      }

      private long estimateCowSize_ ;
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @return Whether the estimateCowSize field is set.
       */
      @Override
      public boolean hasEstimateCowSize() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @return The estimateCowSize.
       */
      @Override
      public long getEstimateCowSize() {
        return estimateCowSize_;
      }
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @param value The estimateCowSize to set.
       * @return This builder for chaining.
       */
      public Builder setEstimateCowSize(long value) {
        bitField0_ |= 0x00040000;
        estimateCowSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearEstimateCowSize() {
        bitField0_ = (bitField0_ & ~0x00040000);
        estimateCowSize_ = 0L;
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:PartitionUpdate)
    }

    // @@protoc_insertion_point(class_scope:PartitionUpdate)
    private static final PartitionUpdate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new PartitionUpdate();
    }

    public static PartitionUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<PartitionUpdate>
        PARSER = new com.google.protobuf.AbstractParser<PartitionUpdate>() {
      @Override
      public PartitionUpdate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PartitionUpdate(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PartitionUpdate> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<PartitionUpdate> getParserForType() {
      return PARSER;
    }

    @Override
    public PartitionUpdate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DynamicPartitionGroupOrBuilder extends
      // @@protoc_insertion_point(interface_extends:DynamicPartitionGroup)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The name.
     */
    String getName();
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return Whether the size field is set.
     */
    boolean hasSize();
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return The size.
     */
    long getSize();

    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return A list containing the partitionNames.
     */
    java.util.List<String>
        getPartitionNamesList();
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return The count of partitionNames.
     */
    int getPartitionNamesCount();
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the element to return.
     * @return The partitionNames at the given index.
     */
    String getPartitionNames(int index);
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the partitionNames at the given index.
     */
    com.google.protobuf.ByteString
        getPartitionNamesBytes(int index);
  }
  /**
   * Protobuf type {@code DynamicPartitionGroup}
   */
  public static final class DynamicPartitionGroup extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:DynamicPartitionGroup)
      DynamicPartitionGroupOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DynamicPartitionGroup.newBuilder() to construct.
    private DynamicPartitionGroup(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DynamicPartitionGroup() {
      name_ = "";
      partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new DynamicPartitionGroup();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DynamicPartitionGroup(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              size_ = input.readUInt64();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                partitionNames_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              partitionNames_.add(bs);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = partitionNames_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              DynamicPartitionGroup.class, Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile Object name_;
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return Whether the name field is set.
     */
    @Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The name.
     */
    @Override
    public String getName() {
      Object ref = name_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The bytes for name.
     */
    @Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SIZE_FIELD_NUMBER = 2;
    private long size_;
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return Whether the size field is set.
     */
    @Override
    public boolean hasSize() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return The size.
     */
    @Override
    public long getSize() {
      return size_;
    }

    public static final int PARTITION_NAMES_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList partitionNames_;
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return A list containing the partitionNames.
     */
    public com.google.protobuf.ProtocolStringList
        getPartitionNamesList() {
      return partitionNames_;
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return The count of partitionNames.
     */
    public int getPartitionNamesCount() {
      return partitionNames_.size();
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the element to return.
     * @return The partitionNames at the given index.
     */
    public String getPartitionNames(int index) {
      return partitionNames_.get(index);
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the partitionNames at the given index.
     */
    public com.google.protobuf.ByteString
        getPartitionNamesBytes(int index) {
      return partitionNames_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, size_);
      }
      for (int i = 0; i < partitionNames_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, partitionNames_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, size_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < partitionNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(partitionNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getPartitionNamesList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof DynamicPartitionGroup)) {
        return super.equals(obj);
      }
      DynamicPartitionGroup other = (DynamicPartitionGroup) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasSize() != other.hasSize()) return false;
      if (hasSize()) {
        if (getSize()
            != other.getSize()) return false;
      }
      if (!getPartitionNamesList()
          .equals(other.getPartitionNamesList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasSize()) {
        hash = (37 * hash) + SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSize());
      }
      if (getPartitionNamesCount() > 0) {
        hash = (37 * hash) + PARTITION_NAMES_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionNamesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static DynamicPartitionGroup parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DynamicPartitionGroup parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DynamicPartitionGroup parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DynamicPartitionGroup parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DynamicPartitionGroup parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DynamicPartitionGroup parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DynamicPartitionGroup parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static DynamicPartitionGroup parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static DynamicPartitionGroup parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static DynamicPartitionGroup parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static DynamicPartitionGroup parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static DynamicPartitionGroup parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(DynamicPartitionGroup prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code DynamicPartitionGroup}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:DynamicPartitionGroup)
        DynamicPartitionGroupOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                DynamicPartitionGroup.class, Builder.class);
      }

      // Construct using UpdateMetadata.DynamicPartitionGroup.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        size_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
      }

      @Override
      public DynamicPartitionGroup getDefaultInstanceForType() {
        return DynamicPartitionGroup.getDefaultInstance();
      }

      @Override
      public DynamicPartitionGroup build() {
        DynamicPartitionGroup result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public DynamicPartitionGroup buildPartial() {
        DynamicPartitionGroup result = new DynamicPartitionGroup(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.size_ = size_;
          to_bitField0_ |= 0x00000002;
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = partitionNames_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.partitionNames_ = partitionNames_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof DynamicPartitionGroup) {
          return mergeFrom((DynamicPartitionGroup)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(DynamicPartitionGroup other) {
        if (other == DynamicPartitionGroup.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasSize()) {
          setSize(other.getSize());
        }
        if (!other.partitionNames_.isEmpty()) {
          if (partitionNames_.isEmpty()) {
            partitionNames_ = other.partitionNames_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensurePartitionNamesIsMutable();
            partitionNames_.addAll(other.partitionNames_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        if (!hasName()) {
          return false;
        }
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        DynamicPartitionGroup parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (DynamicPartitionGroup) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object name_ = "";
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return The name.
       */
      public String getName() {
        Object ref = name_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private long size_ ;
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return Whether the size field is set.
       */
      @Override
      public boolean hasSize() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return The size.
       */
      @Override
      public long getSize() {
        return size_;
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @param value The size to set.
       * @return This builder for chaining.
       */
      public Builder setSize(long value) {
        bitField0_ |= 0x00000002;
        size_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSize() {
        bitField0_ = (bitField0_ & ~0x00000002);
        size_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensurePartitionNamesIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = new com.google.protobuf.LazyStringArrayList(partitionNames_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return A list containing the partitionNames.
       */
      public com.google.protobuf.ProtocolStringList
          getPartitionNamesList() {
        return partitionNames_.getUnmodifiableView();
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return The count of partitionNames.
       */
      public int getPartitionNamesCount() {
        return partitionNames_.size();
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index of the element to return.
       * @return The partitionNames at the given index.
       */
      public String getPartitionNames(int index) {
        return partitionNames_.get(index);
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the partitionNames at the given index.
       */
      public com.google.protobuf.ByteString
          getPartitionNamesBytes(int index) {
        return partitionNames_.getByteString(index);
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index to set the value at.
       * @param value The partitionNames to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionNames(
          int index, String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensurePartitionNamesIsMutable();
        partitionNames_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param value The partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addPartitionNames(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensurePartitionNamesIsMutable();
        partitionNames_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param values The partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addAllPartitionNames(
          Iterable<String> values) {
        ensurePartitionNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, partitionNames_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartitionNames() {
        partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param value The bytes of the partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addPartitionNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensurePartitionNamesIsMutable();
        partitionNames_.add(value);
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:DynamicPartitionGroup)
    }

    // @@protoc_insertion_point(class_scope:DynamicPartitionGroup)
    private static final DynamicPartitionGroup DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new DynamicPartitionGroup();
    }

    public static DynamicPartitionGroup getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<DynamicPartitionGroup>
        PARSER = new com.google.protobuf.AbstractParser<DynamicPartitionGroup>() {
      @Override
      public DynamicPartitionGroup parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DynamicPartitionGroup(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DynamicPartitionGroup> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<DynamicPartitionGroup> getParserForType() {
      return PARSER;
    }

    @Override
    public DynamicPartitionGroup getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DynamicPartitionMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:DynamicPartitionMetadata)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    java.util.List<DynamicPartitionGroup>
        getGroupsList();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    DynamicPartitionGroup getGroups(int index);
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    int getGroupsCount();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    java.util.List<? extends DynamicPartitionGroupOrBuilder>
        getGroupsOrBuilderList();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
        int index);

    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return Whether the snapshotEnabled field is set.
     */
    boolean hasSnapshotEnabled();
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return The snapshotEnabled.
     */
    boolean getSnapshotEnabled();

    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return Whether the vabcEnabled field is set.
     */
    boolean hasVabcEnabled();
    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return The vabcEnabled.
     */
    boolean getVabcEnabled();

    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return Whether the vabcCompressionParam field is set.
     */
    boolean hasVabcCompressionParam();
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The vabcCompressionParam.
     */
    String getVabcCompressionParam();
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The bytes for vabcCompressionParam.
     */
    com.google.protobuf.ByteString
        getVabcCompressionParamBytes();

    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return Whether the cowVersion field is set.
     */
    boolean hasCowVersion();
    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return The cowVersion.
     */
    int getCowVersion();
  }
  /**
   * <pre>
   * Metadata related to all dynamic partitions.
   * </pre>
   *
   * Protobuf type {@code DynamicPartitionMetadata}
   */
  public static final class DynamicPartitionMetadata extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:DynamicPartitionMetadata)
      DynamicPartitionMetadataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DynamicPartitionMetadata.newBuilder() to construct.
    private DynamicPartitionMetadata(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DynamicPartitionMetadata() {
      groups_ = java.util.Collections.emptyList();
      vabcCompressionParam_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new DynamicPartitionMetadata();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DynamicPartitionMetadata(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                groups_ = new java.util.ArrayList<DynamicPartitionGroup>();
                mutable_bitField0_ |= 0x00000001;
              }
              groups_.add(
                  input.readMessage(DynamicPartitionGroup.PARSER, extensionRegistry));
              break;
            }
            case 16: {
              bitField0_ |= 0x00000001;
              snapshotEnabled_ = input.readBool();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000002;
              vabcEnabled_ = input.readBool();
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              vabcCompressionParam_ = bs;
              break;
            }
            case 40: {
              bitField0_ |= 0x00000008;
              cowVersion_ = input.readUInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          groups_ = java.util.Collections.unmodifiableList(groups_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              DynamicPartitionMetadata.class, Builder.class);
    }

    private int bitField0_;
    public static final int GROUPS_FIELD_NUMBER = 1;
    private java.util.List<DynamicPartitionGroup> groups_;
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    @Override
    public java.util.List<DynamicPartitionGroup> getGroupsList() {
      return groups_;
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    @Override
    public java.util.List<? extends DynamicPartitionGroupOrBuilder>
        getGroupsOrBuilderList() {
      return groups_;
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    @Override
    public int getGroupsCount() {
      return groups_.size();
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    @Override
    public DynamicPartitionGroup getGroups(int index) {
      return groups_.get(index);
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .DynamicPartitionGroup groups = 1;</code>
     */
    @Override
    public DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
        int index) {
      return groups_.get(index);
    }

    public static final int SNAPSHOT_ENABLED_FIELD_NUMBER = 2;
    private boolean snapshotEnabled_;
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return Whether the snapshotEnabled field is set.
     */
    @Override
    public boolean hasSnapshotEnabled() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return The snapshotEnabled.
     */
    @Override
    public boolean getSnapshotEnabled() {
      return snapshotEnabled_;
    }

    public static final int VABC_ENABLED_FIELD_NUMBER = 3;
    private boolean vabcEnabled_;
    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return Whether the vabcEnabled field is set.
     */
    @Override
    public boolean hasVabcEnabled() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return The vabcEnabled.
     */
    @Override
    public boolean getVabcEnabled() {
      return vabcEnabled_;
    }

    public static final int VABC_COMPRESSION_PARAM_FIELD_NUMBER = 4;
    private volatile Object vabcCompressionParam_;
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return Whether the vabcCompressionParam field is set.
     */
    @Override
    public boolean hasVabcCompressionParam() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The vabcCompressionParam.
     */
    @Override
    public String getVabcCompressionParam() {
      Object ref = vabcCompressionParam_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          vabcCompressionParam_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The bytes for vabcCompressionParam.
     */
    @Override
    public com.google.protobuf.ByteString
        getVabcCompressionParamBytes() {
      Object ref = vabcCompressionParam_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        vabcCompressionParam_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COW_VERSION_FIELD_NUMBER = 5;
    private int cowVersion_;
    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return Whether the cowVersion field is set.
     */
    @Override
    public boolean hasCowVersion() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return The cowVersion.
     */
    @Override
    public int getCowVersion() {
      return cowVersion_;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getGroupsCount(); i++) {
        if (!getGroups(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < groups_.size(); i++) {
        output.writeMessage(1, groups_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(2, snapshotEnabled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(3, vabcEnabled_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, vabcCompressionParam_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(5, cowVersion_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < groups_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, groups_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, snapshotEnabled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, vabcEnabled_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, vabcCompressionParam_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, cowVersion_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof DynamicPartitionMetadata)) {
        return super.equals(obj);
      }
      DynamicPartitionMetadata other = (DynamicPartitionMetadata) obj;

      if (!getGroupsList()
          .equals(other.getGroupsList())) return false;
      if (hasSnapshotEnabled() != other.hasSnapshotEnabled()) return false;
      if (hasSnapshotEnabled()) {
        if (getSnapshotEnabled()
            != other.getSnapshotEnabled()) return false;
      }
      if (hasVabcEnabled() != other.hasVabcEnabled()) return false;
      if (hasVabcEnabled()) {
        if (getVabcEnabled()
            != other.getVabcEnabled()) return false;
      }
      if (hasVabcCompressionParam() != other.hasVabcCompressionParam()) return false;
      if (hasVabcCompressionParam()) {
        if (!getVabcCompressionParam()
            .equals(other.getVabcCompressionParam())) return false;
      }
      if (hasCowVersion() != other.hasCowVersion()) return false;
      if (hasCowVersion()) {
        if (getCowVersion()
            != other.getCowVersion()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getGroupsCount() > 0) {
        hash = (37 * hash) + GROUPS_FIELD_NUMBER;
        hash = (53 * hash) + getGroupsList().hashCode();
      }
      if (hasSnapshotEnabled()) {
        hash = (37 * hash) + SNAPSHOT_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSnapshotEnabled());
      }
      if (hasVabcEnabled()) {
        hash = (37 * hash) + VABC_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getVabcEnabled());
      }
      if (hasVabcCompressionParam()) {
        hash = (37 * hash) + VABC_COMPRESSION_PARAM_FIELD_NUMBER;
        hash = (53 * hash) + getVabcCompressionParam().hashCode();
      }
      if (hasCowVersion()) {
        hash = (37 * hash) + COW_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getCowVersion();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static DynamicPartitionMetadata parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DynamicPartitionMetadata parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DynamicPartitionMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DynamicPartitionMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DynamicPartitionMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DynamicPartitionMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DynamicPartitionMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static DynamicPartitionMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static DynamicPartitionMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static DynamicPartitionMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static DynamicPartitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static DynamicPartitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(DynamicPartitionMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * Protobuf type {@code DynamicPartitionMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:DynamicPartitionMetadata)
        DynamicPartitionMetadataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                DynamicPartitionMetadata.class, Builder.class);
      }

      // Construct using UpdateMetadata.DynamicPartitionMetadata.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getGroupsFieldBuilder();
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          groupsBuilder_.clear();
        }
        snapshotEnabled_ = false;
        bitField0_ = (bitField0_ & ~0x00000002);
        vabcEnabled_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        vabcCompressionParam_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        cowVersion_ = 0;
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
      }

      @Override
      public DynamicPartitionMetadata getDefaultInstanceForType() {
        return DynamicPartitionMetadata.getDefaultInstance();
      }

      @Override
      public DynamicPartitionMetadata build() {
        DynamicPartitionMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public DynamicPartitionMetadata buildPartial() {
        DynamicPartitionMetadata result = new DynamicPartitionMetadata(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (groupsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            groups_ = java.util.Collections.unmodifiableList(groups_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.groups_ = groups_;
        } else {
          result.groups_ = groupsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.snapshotEnabled_ = snapshotEnabled_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.vabcEnabled_ = vabcEnabled_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.vabcCompressionParam_ = vabcCompressionParam_;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.cowVersion_ = cowVersion_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof DynamicPartitionMetadata) {
          return mergeFrom((DynamicPartitionMetadata)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(DynamicPartitionMetadata other) {
        if (other == DynamicPartitionMetadata.getDefaultInstance()) return this;
        if (groupsBuilder_ == null) {
          if (!other.groups_.isEmpty()) {
            if (groups_.isEmpty()) {
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureGroupsIsMutable();
              groups_.addAll(other.groups_);
            }
            onChanged();
          }
        } else {
          if (!other.groups_.isEmpty()) {
            if (groupsBuilder_.isEmpty()) {
              groupsBuilder_.dispose();
              groupsBuilder_ = null;
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
              groupsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getGroupsFieldBuilder() : null;
            } else {
              groupsBuilder_.addAllMessages(other.groups_);
            }
          }
        }
        if (other.hasSnapshotEnabled()) {
          setSnapshotEnabled(other.getSnapshotEnabled());
        }
        if (other.hasVabcEnabled()) {
          setVabcEnabled(other.getVabcEnabled());
        }
        if (other.hasVabcCompressionParam()) {
          bitField0_ |= 0x00000008;
          vabcCompressionParam_ = other.vabcCompressionParam_;
          onChanged();
        }
        if (other.hasCowVersion()) {
          setCowVersion(other.getCowVersion());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        for (int i = 0; i < getGroupsCount(); i++) {
          if (!getGroups(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        DynamicPartitionMetadata parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (DynamicPartitionMetadata) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<DynamicPartitionGroup> groups_ =
        java.util.Collections.emptyList();
      private void ensureGroupsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          groups_ = new java.util.ArrayList<DynamicPartitionGroup>(groups_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          DynamicPartitionGroup, DynamicPartitionGroup.Builder, DynamicPartitionGroupOrBuilder> groupsBuilder_;

      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<DynamicPartitionGroup> getGroupsList() {
        if (groupsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(groups_);
        } else {
          return groupsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public int getGroupsCount() {
        if (groupsBuilder_ == null) {
          return groups_.size();
        } else {
          return groupsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public DynamicPartitionGroup getGroups(int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);
        } else {
          return groupsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.set(index, value);
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.set(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(index, value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addAllGroups(
          Iterable<? extends DynamicPartitionGroup> values) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, groups_);
          onChanged();
        } else {
          groupsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder clearGroups() {
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          groupsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public Builder removeGroups(int index) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.remove(index);
          onChanged();
        } else {
          groupsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public DynamicPartitionGroup.Builder getGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
          int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);  } else {
          return groupsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<? extends DynamicPartitionGroupOrBuilder>
           getGroupsOrBuilderList() {
        if (groupsBuilder_ != null) {
          return groupsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(groups_);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public DynamicPartitionGroup.Builder addGroupsBuilder() {
        return getGroupsFieldBuilder().addBuilder(
            DynamicPartitionGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public DynamicPartitionGroup.Builder addGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().addBuilder(
            index, DynamicPartitionGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<DynamicPartitionGroup.Builder>
           getGroupsBuilderList() {
        return getGroupsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          DynamicPartitionGroup, DynamicPartitionGroup.Builder, DynamicPartitionGroupOrBuilder>
          getGroupsFieldBuilder() {
        if (groupsBuilder_ == null) {
          groupsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              DynamicPartitionGroup, DynamicPartitionGroup.Builder, DynamicPartitionGroupOrBuilder>(
                  groups_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          groups_ = null;
        }
        return groupsBuilder_;
      }

      private boolean snapshotEnabled_ ;
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return Whether the snapshotEnabled field is set.
       */
      @Override
      public boolean hasSnapshotEnabled() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return The snapshotEnabled.
       */
      @Override
      public boolean getSnapshotEnabled() {
        return snapshotEnabled_;
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @param value The snapshotEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setSnapshotEnabled(boolean value) {
        bitField0_ |= 0x00000002;
        snapshotEnabled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSnapshotEnabled() {
        bitField0_ = (bitField0_ & ~0x00000002);
        snapshotEnabled_ = false;
        onChanged();
        return this;
      }

      private boolean vabcEnabled_ ;
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @return Whether the vabcEnabled field is set.
       */
      @Override
      public boolean hasVabcEnabled() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @return The vabcEnabled.
       */
      @Override
      public boolean getVabcEnabled() {
        return vabcEnabled_;
      }
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @param value The vabcEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setVabcEnabled(boolean value) {
        bitField0_ |= 0x00000004;
        vabcEnabled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearVabcEnabled() {
        bitField0_ = (bitField0_ & ~0x00000004);
        vabcEnabled_ = false;
        onChanged();
        return this;
      }

      private Object vabcCompressionParam_ = "";
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return Whether the vabcCompressionParam field is set.
       */
      public boolean hasVabcCompressionParam() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return The vabcCompressionParam.
       */
      public String getVabcCompressionParam() {
        Object ref = vabcCompressionParam_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            vabcCompressionParam_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return The bytes for vabcCompressionParam.
       */
      public com.google.protobuf.ByteString
          getVabcCompressionParamBytes() {
        Object ref = vabcCompressionParam_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          vabcCompressionParam_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @param value The vabcCompressionParam to set.
       * @return This builder for chaining.
       */
      public Builder setVabcCompressionParam(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        vabcCompressionParam_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVabcCompressionParam() {
        bitField0_ = (bitField0_ & ~0x00000008);
        vabcCompressionParam_ = getDefaultInstance().getVabcCompressionParam();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @param value The bytes for vabcCompressionParam to set.
       * @return This builder for chaining.
       */
      public Builder setVabcCompressionParamBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        vabcCompressionParam_ = value;
        onChanged();
        return this;
      }

      private int cowVersion_ ;
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @return Whether the cowVersion field is set.
       */
      @Override
      public boolean hasCowVersion() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @return The cowVersion.
       */
      @Override
      public int getCowVersion() {
        return cowVersion_;
      }
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @param value The cowVersion to set.
       * @return This builder for chaining.
       */
      public Builder setCowVersion(int value) {
        bitField0_ |= 0x00000010;
        cowVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCowVersion() {
        bitField0_ = (bitField0_ & ~0x00000010);
        cowVersion_ = 0;
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:DynamicPartitionMetadata)
    }

    // @@protoc_insertion_point(class_scope:DynamicPartitionMetadata)
    private static final DynamicPartitionMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new DynamicPartitionMetadata();
    }

    public static DynamicPartitionMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<DynamicPartitionMetadata>
        PARSER = new com.google.protobuf.AbstractParser<DynamicPartitionMetadata>() {
      @Override
      public DynamicPartitionMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DynamicPartitionMetadata(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DynamicPartitionMetadata> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<DynamicPartitionMetadata> getParserForType() {
      return PARSER;
    }

    @Override
    public DynamicPartitionMetadata getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ApexInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ApexInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string package_name = 1;</code>
     * @return Whether the packageName field is set.
     */
    boolean hasPackageName();
    /**
     * <code>optional string package_name = 1;</code>
     * @return The packageName.
     */
    String getPackageName();
    /**
     * <code>optional string package_name = 1;</code>
     * @return The bytes for packageName.
     */
    com.google.protobuf.ByteString
        getPackageNameBytes();

    /**
     * <code>optional int64 version = 2;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <code>optional int64 version = 2;</code>
     * @return The version.
     */
    long getVersion();

    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return Whether the isCompressed field is set.
     */
    boolean hasIsCompressed();
    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return The isCompressed.
     */
    boolean getIsCompressed();

    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return Whether the decompressedSize field is set.
     */
    boolean hasDecompressedSize();
    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return The decompressedSize.
     */
    long getDecompressedSize();
  }
  /**
   * <pre>
   * Definition has been duplicated from
   * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
   * </pre>
   *
   * Protobuf type {@code ApexInfo}
   */
  public static final class ApexInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:ApexInfo)
      ApexInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ApexInfo.newBuilder() to construct.
    private ApexInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ApexInfo() {
      packageName_ = "";
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new ApexInfo();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ApexInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              packageName_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              version_ = input.readInt64();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              isCompressed_ = input.readBool();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              decompressedSize_ = input.readInt64();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ApexInfo.class, Builder.class);
    }

    private int bitField0_;
    public static final int PACKAGE_NAME_FIELD_NUMBER = 1;
    private volatile Object packageName_;
    /**
     * <code>optional string package_name = 1;</code>
     * @return Whether the packageName field is set.
     */
    @Override
    public boolean hasPackageName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string package_name = 1;</code>
     * @return The packageName.
     */
    @Override
    public String getPackageName() {
      Object ref = packageName_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          packageName_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string package_name = 1;</code>
     * @return The bytes for packageName.
     */
    @Override
    public com.google.protobuf.ByteString
        getPackageNameBytes() {
      Object ref = packageName_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        packageName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    private long version_;
    /**
     * <code>optional int64 version = 2;</code>
     * @return Whether the version field is set.
     */
    @Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int64 version = 2;</code>
     * @return The version.
     */
    @Override
    public long getVersion() {
      return version_;
    }

    public static final int IS_COMPRESSED_FIELD_NUMBER = 3;
    private boolean isCompressed_;
    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return Whether the isCompressed field is set.
     */
    @Override
    public boolean hasIsCompressed() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return The isCompressed.
     */
    @Override
    public boolean getIsCompressed() {
      return isCompressed_;
    }

    public static final int DECOMPRESSED_SIZE_FIELD_NUMBER = 4;
    private long decompressedSize_;
    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return Whether the decompressedSize field is set.
     */
    @Override
    public boolean hasDecompressedSize() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return The decompressedSize.
     */
    @Override
    public long getDecompressedSize() {
      return decompressedSize_;
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, packageName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt64(2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, isCompressed_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt64(4, decompressedSize_);
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, packageName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, isCompressed_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, decompressedSize_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ApexInfo)) {
        return super.equals(obj);
      }
      ApexInfo other = (ApexInfo) obj;

      if (hasPackageName() != other.hasPackageName()) return false;
      if (hasPackageName()) {
        if (!getPackageName()
            .equals(other.getPackageName())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (getVersion()
            != other.getVersion()) return false;
      }
      if (hasIsCompressed() != other.hasIsCompressed()) return false;
      if (hasIsCompressed()) {
        if (getIsCompressed()
            != other.getIsCompressed()) return false;
      }
      if (hasDecompressedSize() != other.hasDecompressedSize()) return false;
      if (hasDecompressedSize()) {
        if (getDecompressedSize()
            != other.getDecompressedSize()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPackageName()) {
        hash = (37 * hash) + PACKAGE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getPackageName().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getVersion());
      }
      if (hasIsCompressed()) {
        hash = (37 * hash) + IS_COMPRESSED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsCompressed());
      }
      if (hasDecompressedSize()) {
        hash = (37 * hash) + DECOMPRESSED_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDecompressedSize());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ApexInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ApexInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ApexInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ApexInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ApexInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ApexInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ApexInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ApexInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static ApexInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static ApexInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ApexInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ApexInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ApexInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Definition has been duplicated from
     * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
     * </pre>
     *
     * Protobuf type {@code ApexInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ApexInfo)
        ApexInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ApexInfo.class, Builder.class);
      }

      // Construct using UpdateMetadata.ApexInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        packageName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        version_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        isCompressed_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        decompressedSize_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_descriptor;
      }

      @Override
      public ApexInfo getDefaultInstanceForType() {
        return ApexInfo.getDefaultInstance();
      }

      @Override
      public ApexInfo build() {
        ApexInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ApexInfo buildPartial() {
        ApexInfo result = new ApexInfo(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.packageName_ = packageName_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.isCompressed_ = isCompressed_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.decompressedSize_ = decompressedSize_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ApexInfo) {
          return mergeFrom((ApexInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ApexInfo other) {
        if (other == ApexInfo.getDefaultInstance()) return this;
        if (other.hasPackageName()) {
          bitField0_ |= 0x00000001;
          packageName_ = other.packageName_;
          onChanged();
        }
        if (other.hasVersion()) {
          setVersion(other.getVersion());
        }
        if (other.hasIsCompressed()) {
          setIsCompressed(other.getIsCompressed());
        }
        if (other.hasDecompressedSize()) {
          setDecompressedSize(other.getDecompressedSize());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        ApexInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (ApexInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object packageName_ = "";
      /**
       * <code>optional string package_name = 1;</code>
       * @return Whether the packageName field is set.
       */
      public boolean hasPackageName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @return The packageName.
       */
      public String getPackageName() {
        Object ref = packageName_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            packageName_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @return The bytes for packageName.
       */
      public com.google.protobuf.ByteString
          getPackageNameBytes() {
        Object ref = packageName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          packageName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @param value The packageName to set.
       * @return This builder for chaining.
       */
      public Builder setPackageName(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        packageName_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPackageName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        packageName_ = getDefaultInstance().getPackageName();
        onChanged();
        return this;
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @param value The bytes for packageName to set.
       * @return This builder for chaining.
       */
      public Builder setPackageNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        packageName_ = value;
        onChanged();
        return this;
      }

      private long version_ ;
      /**
       * <code>optional int64 version = 2;</code>
       * @return Whether the version field is set.
       */
      @Override
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional int64 version = 2;</code>
       * @return The version.
       */
      @Override
      public long getVersion() {
        return version_;
      }
      /**
       * <code>optional int64 version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(long value) {
        bitField0_ |= 0x00000002;
        version_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        version_ = 0L;
        onChanged();
        return this;
      }

      private boolean isCompressed_ ;
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @return Whether the isCompressed field is set.
       */
      @Override
      public boolean hasIsCompressed() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @return The isCompressed.
       */
      @Override
      public boolean getIsCompressed() {
        return isCompressed_;
      }
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @param value The isCompressed to set.
       * @return This builder for chaining.
       */
      public Builder setIsCompressed(boolean value) {
        bitField0_ |= 0x00000004;
        isCompressed_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsCompressed() {
        bitField0_ = (bitField0_ & ~0x00000004);
        isCompressed_ = false;
        onChanged();
        return this;
      }

      private long decompressedSize_ ;
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @return Whether the decompressedSize field is set.
       */
      @Override
      public boolean hasDecompressedSize() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @return The decompressedSize.
       */
      @Override
      public long getDecompressedSize() {
        return decompressedSize_;
      }
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @param value The decompressedSize to set.
       * @return This builder for chaining.
       */
      public Builder setDecompressedSize(long value) {
        bitField0_ |= 0x00000008;
        decompressedSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDecompressedSize() {
        bitField0_ = (bitField0_ & ~0x00000008);
        decompressedSize_ = 0L;
        onChanged();
        return this;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:ApexInfo)
    }

    // @@protoc_insertion_point(class_scope:ApexInfo)
    private static final ApexInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ApexInfo();
    }

    public static ApexInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<ApexInfo>
        PARSER = new com.google.protobuf.AbstractParser<ApexInfo>() {
      @Override
      public ApexInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ApexInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ApexInfo> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ApexInfo> getParserForType() {
      return PARSER;
    }

    @Override
    public ApexInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ApexMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ApexMetadata)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    java.util.List<ApexInfo>
        getApexInfoList();
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    ApexInfo getApexInfo(int index);
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    int getApexInfoCount();
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    java.util.List<? extends ApexInfoOrBuilder>
        getApexInfoOrBuilderList();
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    ApexInfoOrBuilder getApexInfoOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Definition has been duplicated from
   * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
   * </pre>
   *
   * Protobuf type {@code ApexMetadata}
   */
  public static final class ApexMetadata extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:ApexMetadata)
      ApexMetadataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ApexMetadata.newBuilder() to construct.
    private ApexMetadata(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ApexMetadata() {
      apexInfo_ = java.util.Collections.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new ApexMetadata();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ApexMetadata(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                apexInfo_ = new java.util.ArrayList<ApexInfo>();
                mutable_bitField0_ |= 0x00000001;
              }
              apexInfo_.add(
                  input.readMessage(ApexInfo.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          apexInfo_ = java.util.Collections.unmodifiableList(apexInfo_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ApexMetadata.class, Builder.class);
    }

    public static final int APEX_INFO_FIELD_NUMBER = 1;
    private java.util.List<ApexInfo> apexInfo_;
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    @Override
    public java.util.List<ApexInfo> getApexInfoList() {
      return apexInfo_;
    }
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    @Override
    public java.util.List<? extends ApexInfoOrBuilder>
        getApexInfoOrBuilderList() {
      return apexInfo_;
    }
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    @Override
    public int getApexInfoCount() {
      return apexInfo_.size();
    }
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    @Override
    public ApexInfo getApexInfo(int index) {
      return apexInfo_.get(index);
    }
    /**
     * <code>repeated .ApexInfo apex_info = 1;</code>
     */
    @Override
    public ApexInfoOrBuilder getApexInfoOrBuilder(
        int index) {
      return apexInfo_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < apexInfo_.size(); i++) {
        output.writeMessage(1, apexInfo_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < apexInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, apexInfo_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ApexMetadata)) {
        return super.equals(obj);
      }
      ApexMetadata other = (ApexMetadata) obj;

      if (!getApexInfoList()
          .equals(other.getApexInfoList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getApexInfoCount() > 0) {
        hash = (37 * hash) + APEX_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getApexInfoList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ApexMetadata parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ApexMetadata parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ApexMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ApexMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ApexMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ApexMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ApexMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ApexMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static ApexMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static ApexMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ApexMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ApexMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ApexMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Definition has been duplicated from
     * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
     * </pre>
     *
     * Protobuf type {@code ApexMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ApexMetadata)
        ApexMetadataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ApexMetadata.class, Builder.class);
      }

      // Construct using UpdateMetadata.ApexMetadata.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getApexInfoFieldBuilder();
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          apexInfoBuilder_.clear();
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_descriptor;
      }

      @Override
      public ApexMetadata getDefaultInstanceForType() {
        return ApexMetadata.getDefaultInstance();
      }

      @Override
      public ApexMetadata build() {
        ApexMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public ApexMetadata buildPartial() {
        ApexMetadata result = new ApexMetadata(this);
        int from_bitField0_ = bitField0_;
        if (apexInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            apexInfo_ = java.util.Collections.unmodifiableList(apexInfo_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.apexInfo_ = apexInfo_;
        } else {
          result.apexInfo_ = apexInfoBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ApexMetadata) {
          return mergeFrom((ApexMetadata)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ApexMetadata other) {
        if (other == ApexMetadata.getDefaultInstance()) return this;
        if (apexInfoBuilder_ == null) {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfo_.isEmpty()) {
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureApexInfoIsMutable();
              apexInfo_.addAll(other.apexInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfoBuilder_.isEmpty()) {
              apexInfoBuilder_.dispose();
              apexInfoBuilder_ = null;
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00000001);
              apexInfoBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getApexInfoFieldBuilder() : null;
            } else {
              apexInfoBuilder_.addAllMessages(other.apexInfo_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        ApexMetadata parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (ApexMetadata) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<ApexInfo> apexInfo_ =
        java.util.Collections.emptyList();
      private void ensureApexInfoIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          apexInfo_ = new java.util.ArrayList<ApexInfo>(apexInfo_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ApexInfo, ApexInfo.Builder, ApexInfoOrBuilder> apexInfoBuilder_;

      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public java.util.List<ApexInfo> getApexInfoList() {
        if (apexInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(apexInfo_);
        } else {
          return apexInfoBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public int getApexInfoCount() {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.size();
        } else {
          return apexInfoBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public ApexInfo getApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);
        } else {
          return apexInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder setApexInfo(
          int index, ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.set(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder setApexInfo(
          int index, ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(
          int index, ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(
          ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(
          int index, ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder addAllApexInfo(
          Iterable<? extends ApexInfo> values) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, apexInfo_);
          onChanged();
        } else {
          apexInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder clearApexInfo() {
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          apexInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public Builder removeApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.remove(index);
          onChanged();
        } else {
          apexInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public ApexInfo.Builder getApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public ApexInfoOrBuilder getApexInfoOrBuilder(
          int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);  } else {
          return apexInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public java.util.List<? extends ApexInfoOrBuilder>
           getApexInfoOrBuilderList() {
        if (apexInfoBuilder_ != null) {
          return apexInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(apexInfo_);
        }
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public ApexInfo.Builder addApexInfoBuilder() {
        return getApexInfoFieldBuilder().addBuilder(
            ApexInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public ApexInfo.Builder addApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().addBuilder(
            index, ApexInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .ApexInfo apex_info = 1;</code>
       */
      public java.util.List<ApexInfo.Builder>
           getApexInfoBuilderList() {
        return getApexInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ApexInfo, ApexInfo.Builder, ApexInfoOrBuilder>
          getApexInfoFieldBuilder() {
        if (apexInfoBuilder_ == null) {
          apexInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ApexInfo, ApexInfo.Builder, ApexInfoOrBuilder>(
                  apexInfo_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          apexInfo_ = null;
        }
        return apexInfoBuilder_;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:ApexMetadata)
    }

    // @@protoc_insertion_point(class_scope:ApexMetadata)
    private static final ApexMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ApexMetadata();
    }

    public static ApexMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<ApexMetadata>
        PARSER = new com.google.protobuf.AbstractParser<ApexMetadata>() {
      @Override
      public ApexMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ApexMetadata(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ApexMetadata> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ApexMetadata> getParserForType() {
      return PARSER;
    }

    @Override
    public ApexMetadata getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeltaArchiveManifestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:DeltaArchiveManifest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Deprecated java.util.List<InstallOperation>
        getInstallOperationsList();
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Deprecated InstallOperation getInstallOperations(int index);
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Deprecated int getInstallOperationsCount();
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Deprecated java.util.List<? extends InstallOperationOrBuilder>
        getInstallOperationsOrBuilderList();
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Deprecated InstallOperationOrBuilder getInstallOperationsOrBuilder(
        int index);

    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Deprecated java.util.List<InstallOperation>
        getKernelInstallOperationsList();
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Deprecated InstallOperation getKernelInstallOperations(int index);
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Deprecated int getKernelInstallOperationsCount();
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Deprecated java.util.List<? extends InstallOperationOrBuilder>
        getKernelInstallOperationsOrBuilderList();
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Deprecated InstallOperationOrBuilder getKernelInstallOperationsOrBuilder(
        int index);

    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return Whether the blockSize field is set.
     */
    boolean hasBlockSize();
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return The blockSize.
     */
    int getBlockSize();

    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return Whether the signaturesOffset field is set.
     */
    boolean hasSignaturesOffset();
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return The signaturesOffset.
     */
    long getSignaturesOffset();

    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return Whether the signaturesSize field is set.
     */
    boolean hasSignaturesSize();
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return The signaturesSize.
     */
    long getSignaturesSize();

    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
     * @return Whether the oldKernelInfo field is set.
     */
    @Deprecated boolean hasOldKernelInfo();
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
     * @return The oldKernelInfo.
     */
    @Deprecated PartitionInfo getOldKernelInfo();
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
     */
    @Deprecated PartitionInfoOrBuilder getOldKernelInfoOrBuilder();

    /**
     * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
     * @return Whether the newKernelInfo field is set.
     */
    @Deprecated boolean hasNewKernelInfo();
    /**
     * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
     * @return The newKernelInfo.
     */
    @Deprecated PartitionInfo getNewKernelInfo();
    /**
     * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
     */
    @Deprecated PartitionInfoOrBuilder getNewKernelInfoOrBuilder();

    /**
     * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
     * @return Whether the oldRootfsInfo field is set.
     */
    @Deprecated boolean hasOldRootfsInfo();
    /**
     * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
     * @return The oldRootfsInfo.
     */
    @Deprecated PartitionInfo getOldRootfsInfo();
    /**
     * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
     */
    @Deprecated PartitionInfoOrBuilder getOldRootfsInfoOrBuilder();

    /**
     * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
     * @return Whether the newRootfsInfo field is set.
     */
    @Deprecated boolean hasNewRootfsInfo();
    /**
     * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
     * @return The newRootfsInfo.
     */
    @Deprecated PartitionInfo getNewRootfsInfo();
    /**
     * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
     */
    @Deprecated PartitionInfoOrBuilder getNewRootfsInfoOrBuilder();

    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
     * @return Whether the oldImageInfo field is set.
     */
    @Deprecated boolean hasOldImageInfo();
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
     * @return The oldImageInfo.
     */
    @Deprecated ImageInfo getOldImageInfo();
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
     */
    @Deprecated ImageInfoOrBuilder getOldImageInfoOrBuilder();

    /**
     * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
     * @return Whether the newImageInfo field is set.
     */
    @Deprecated boolean hasNewImageInfo();
    /**
     * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
     * @return The newImageInfo.
     */
    @Deprecated ImageInfo getNewImageInfo();
    /**
     * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
     */
    @Deprecated ImageInfoOrBuilder getNewImageInfoOrBuilder();

    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return Whether the minorVersion field is set.
     */
    boolean hasMinorVersion();
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return The minorVersion.
     */
    int getMinorVersion();

    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    java.util.List<PartitionUpdate>
        getPartitionsList();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    PartitionUpdate getPartitions(int index);
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    int getPartitionsCount();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    java.util.List<? extends PartitionUpdateOrBuilder>
        getPartitionsOrBuilderList();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    PartitionUpdateOrBuilder getPartitionsOrBuilder(
        int index);

    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return Whether the maxTimestamp field is set.
     */
    boolean hasMaxTimestamp();
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return The maxTimestamp.
     */
    long getMaxTimestamp();

    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return Whether the dynamicPartitionMetadata field is set.
     */
    boolean hasDynamicPartitionMetadata();
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return The dynamicPartitionMetadata.
     */
    DynamicPartitionMetadata getDynamicPartitionMetadata();
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     */
    DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder();

    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return Whether the partialUpdate field is set.
     */
    boolean hasPartialUpdate();
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return The partialUpdate.
     */
    boolean getPartialUpdate();

    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    java.util.List<ApexInfo>
        getApexInfoList();
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    ApexInfo getApexInfo(int index);
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    int getApexInfoCount();
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    java.util.List<? extends ApexInfoOrBuilder>
        getApexInfoOrBuilderList();
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    ApexInfoOrBuilder getApexInfoOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code DeltaArchiveManifest}
   */
  public static final class DeltaArchiveManifest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:DeltaArchiveManifest)
      DeltaArchiveManifestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeltaArchiveManifest.newBuilder() to construct.
    private DeltaArchiveManifest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeltaArchiveManifest() {
      installOperations_ = java.util.Collections.emptyList();
      kernelInstallOperations_ = java.util.Collections.emptyList();
      blockSize_ = 4096;
      partitions_ = java.util.Collections.emptyList();
      apexInfo_ = java.util.Collections.emptyList();
    }

    @Override
    @SuppressWarnings({"unused"})
    protected Object newInstance(
        UnusedPrivateParameter unused) {
      return new DeltaArchiveManifest();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeltaArchiveManifest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                installOperations_ = new java.util.ArrayList<InstallOperation>();
                mutable_bitField0_ |= 0x00000001;
              }
              installOperations_.add(
                  input.readMessage(InstallOperation.PARSER, extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                kernelInstallOperations_ = new java.util.ArrayList<InstallOperation>();
                mutable_bitField0_ |= 0x00000002;
              }
              kernelInstallOperations_.add(
                  input.readMessage(InstallOperation.PARSER, extensionRegistry));
              break;
            }
            case 24: {
              bitField0_ |= 0x00000001;
              blockSize_ = input.readUInt32();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000002;
              signaturesOffset_ = input.readUInt64();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000004;
              signaturesSize_ = input.readUInt64();
              break;
            }
            case 50: {
              PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = oldKernelInfo_.toBuilder();
              }
              oldKernelInfo_ = input.readMessage(PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldKernelInfo_);
                oldKernelInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 58: {
              PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) != 0)) {
                subBuilder = newKernelInfo_.toBuilder();
              }
              newKernelInfo_ = input.readMessage(PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newKernelInfo_);
                newKernelInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 66: {
              PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) != 0)) {
                subBuilder = oldRootfsInfo_.toBuilder();
              }
              oldRootfsInfo_ = input.readMessage(PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldRootfsInfo_);
                oldRootfsInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 74: {
              PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) != 0)) {
                subBuilder = newRootfsInfo_.toBuilder();
              }
              newRootfsInfo_ = input.readMessage(PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newRootfsInfo_);
                newRootfsInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 82: {
              ImageInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) != 0)) {
                subBuilder = oldImageInfo_.toBuilder();
              }
              oldImageInfo_ = input.readMessage(ImageInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldImageInfo_);
                oldImageInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 90: {
              ImageInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) != 0)) {
                subBuilder = newImageInfo_.toBuilder();
              }
              newImageInfo_ = input.readMessage(ImageInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newImageInfo_);
                newImageInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 96: {
              bitField0_ |= 0x00000200;
              minorVersion_ = input.readUInt32();
              break;
            }
            case 106: {
              if (!((mutable_bitField0_ & 0x00001000) != 0)) {
                partitions_ = new java.util.ArrayList<PartitionUpdate>();
                mutable_bitField0_ |= 0x00001000;
              }
              partitions_.add(
                  input.readMessage(PartitionUpdate.PARSER, extensionRegistry));
              break;
            }
            case 112: {
              bitField0_ |= 0x00000400;
              maxTimestamp_ = input.readInt64();
              break;
            }
            case 122: {
              DynamicPartitionMetadata.Builder subBuilder = null;
              if (((bitField0_ & 0x00000800) != 0)) {
                subBuilder = dynamicPartitionMetadata_.toBuilder();
              }
              dynamicPartitionMetadata_ = input.readMessage(DynamicPartitionMetadata.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(dynamicPartitionMetadata_);
                dynamicPartitionMetadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000800;
              break;
            }
            case 128: {
              bitField0_ |= 0x00001000;
              partialUpdate_ = input.readBool();
              break;
            }
            case 138: {
              if (!((mutable_bitField0_ & 0x00010000) != 0)) {
                apexInfo_ = new java.util.ArrayList<ApexInfo>();
                mutable_bitField0_ |= 0x00010000;
              }
              apexInfo_.add(
                  input.readMessage(ApexInfo.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          installOperations_ = java.util.Collections.unmodifiableList(installOperations_);
        }
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          kernelInstallOperations_ = java.util.Collections.unmodifiableList(kernelInstallOperations_);
        }
        if (((mutable_bitField0_ & 0x00001000) != 0)) {
          partitions_ = java.util.Collections.unmodifiableList(partitions_);
        }
        if (((mutable_bitField0_ & 0x00010000) != 0)) {
          apexInfo_ = java.util.Collections.unmodifiableList(apexInfo_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
    }

    @Override
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              DeltaArchiveManifest.class, Builder.class);
    }

    private int bitField0_;
    public static final int INSTALL_OPERATIONS_FIELD_NUMBER = 1;
    private java.util.List<InstallOperation> installOperations_;
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Override
    @Deprecated public java.util.List<InstallOperation> getInstallOperationsList() {
      return installOperations_;
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Override
    @Deprecated public java.util.List<? extends InstallOperationOrBuilder>
        getInstallOperationsOrBuilderList() {
      return installOperations_;
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Override
    @Deprecated public int getInstallOperationsCount() {
      return installOperations_.size();
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Override
    @Deprecated public InstallOperation getInstallOperations(int index) {
      return installOperations_.get(index);
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
     */
    @Override
    @Deprecated public InstallOperationOrBuilder getInstallOperationsOrBuilder(
        int index) {
      return installOperations_.get(index);
    }

    public static final int KERNEL_INSTALL_OPERATIONS_FIELD_NUMBER = 2;
    private java.util.List<InstallOperation> kernelInstallOperations_;
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Override
    @Deprecated public java.util.List<InstallOperation> getKernelInstallOperationsList() {
      return kernelInstallOperations_;
    }
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Override
    @Deprecated public java.util.List<? extends InstallOperationOrBuilder>
        getKernelInstallOperationsOrBuilderList() {
      return kernelInstallOperations_;
    }
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Override
    @Deprecated public int getKernelInstallOperationsCount() {
      return kernelInstallOperations_.size();
    }
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Override
    @Deprecated public InstallOperation getKernelInstallOperations(int index) {
      return kernelInstallOperations_.get(index);
    }
    /**
     * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
     */
    @Override
    @Deprecated public InstallOperationOrBuilder getKernelInstallOperationsOrBuilder(
        int index) {
      return kernelInstallOperations_.get(index);
    }

    public static final int BLOCK_SIZE_FIELD_NUMBER = 3;
    private int blockSize_;
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return Whether the blockSize field is set.
     */
    @Override
    public boolean hasBlockSize() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return The blockSize.
     */
    @Override
    public int getBlockSize() {
      return blockSize_;
    }

    public static final int SIGNATURES_OFFSET_FIELD_NUMBER = 4;
    private long signaturesOffset_;
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return Whether the signaturesOffset field is set.
     */
    @Override
    public boolean hasSignaturesOffset() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return The signaturesOffset.
     */
    @Override
    public long getSignaturesOffset() {
      return signaturesOffset_;
    }

    public static final int SIGNATURES_SIZE_FIELD_NUMBER = 5;
    private long signaturesSize_;
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return Whether the signaturesSize field is set.
     */
    @Override
    public boolean hasSignaturesSize() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return The signaturesSize.
     */
    @Override
    public long getSignaturesSize() {
      return signaturesSize_;
    }

    public static final int OLD_KERNEL_INFO_FIELD_NUMBER = 6;
    private PartitionInfo oldKernelInfo_;
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
     * @return Whether the oldKernelInfo field is set.
     */
    @Override
    @Deprecated public boolean hasOldKernelInfo() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
     * @return The oldKernelInfo.
     */
    @Override
    @Deprecated public PartitionInfo getOldKernelInfo() {
      return oldKernelInfo_ == null ? PartitionInfo.getDefaultInstance() : oldKernelInfo_;
    }
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
     */
    @Override
    @Deprecated public PartitionInfoOrBuilder getOldKernelInfoOrBuilder() {
      return oldKernelInfo_ == null ? PartitionInfo.getDefaultInstance() : oldKernelInfo_;
    }

    public static final int NEW_KERNEL_INFO_FIELD_NUMBER = 7;
    private PartitionInfo newKernelInfo_;
    /**
     * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
     * @return Whether the newKernelInfo field is set.
     */
    @Override
    @Deprecated public boolean hasNewKernelInfo() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
     * @return The newKernelInfo.
     */
    @Override
    @Deprecated public PartitionInfo getNewKernelInfo() {
      return newKernelInfo_ == null ? PartitionInfo.getDefaultInstance() : newKernelInfo_;
    }
    /**
     * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
     */
    @Override
    @Deprecated public PartitionInfoOrBuilder getNewKernelInfoOrBuilder() {
      return newKernelInfo_ == null ? PartitionInfo.getDefaultInstance() : newKernelInfo_;
    }

    public static final int OLD_ROOTFS_INFO_FIELD_NUMBER = 8;
    private PartitionInfo oldRootfsInfo_;
    /**
     * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
     * @return Whether the oldRootfsInfo field is set.
     */
    @Override
    @Deprecated public boolean hasOldRootfsInfo() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
     * @return The oldRootfsInfo.
     */
    @Override
    @Deprecated public PartitionInfo getOldRootfsInfo() {
      return oldRootfsInfo_ == null ? PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
    }
    /**
     * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
     */
    @Override
    @Deprecated public PartitionInfoOrBuilder getOldRootfsInfoOrBuilder() {
      return oldRootfsInfo_ == null ? PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
    }

    public static final int NEW_ROOTFS_INFO_FIELD_NUMBER = 9;
    private PartitionInfo newRootfsInfo_;
    /**
     * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
     * @return Whether the newRootfsInfo field is set.
     */
    @Override
    @Deprecated public boolean hasNewRootfsInfo() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
     * @return The newRootfsInfo.
     */
    @Override
    @Deprecated public PartitionInfo getNewRootfsInfo() {
      return newRootfsInfo_ == null ? PartitionInfo.getDefaultInstance() : newRootfsInfo_;
    }
    /**
     * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
     */
    @Override
    @Deprecated public PartitionInfoOrBuilder getNewRootfsInfoOrBuilder() {
      return newRootfsInfo_ == null ? PartitionInfo.getDefaultInstance() : newRootfsInfo_;
    }

    public static final int OLD_IMAGE_INFO_FIELD_NUMBER = 10;
    private ImageInfo oldImageInfo_;
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
     * @return Whether the oldImageInfo field is set.
     */
    @Override
    @Deprecated public boolean hasOldImageInfo() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
     * @return The oldImageInfo.
     */
    @Override
    @Deprecated public ImageInfo getOldImageInfo() {
      return oldImageInfo_ == null ? ImageInfo.getDefaultInstance() : oldImageInfo_;
    }
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
     */
    @Override
    @Deprecated public ImageInfoOrBuilder getOldImageInfoOrBuilder() {
      return oldImageInfo_ == null ? ImageInfo.getDefaultInstance() : oldImageInfo_;
    }

    public static final int NEW_IMAGE_INFO_FIELD_NUMBER = 11;
    private ImageInfo newImageInfo_;
    /**
     * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
     * @return Whether the newImageInfo field is set.
     */
    @Override
    @Deprecated public boolean hasNewImageInfo() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
     * @return The newImageInfo.
     */
    @Override
    @Deprecated public ImageInfo getNewImageInfo() {
      return newImageInfo_ == null ? ImageInfo.getDefaultInstance() : newImageInfo_;
    }
    /**
     * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
     */
    @Override
    @Deprecated public ImageInfoOrBuilder getNewImageInfoOrBuilder() {
      return newImageInfo_ == null ? ImageInfo.getDefaultInstance() : newImageInfo_;
    }

    public static final int MINOR_VERSION_FIELD_NUMBER = 12;
    private int minorVersion_;
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return Whether the minorVersion field is set.
     */
    @Override
    public boolean hasMinorVersion() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return The minorVersion.
     */
    @Override
    public int getMinorVersion() {
      return minorVersion_;
    }

    public static final int PARTITIONS_FIELD_NUMBER = 13;
    private java.util.List<PartitionUpdate> partitions_;
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    @Override
    public java.util.List<PartitionUpdate> getPartitionsList() {
      return partitions_;
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    @Override
    public java.util.List<? extends PartitionUpdateOrBuilder>
        getPartitionsOrBuilderList() {
      return partitions_;
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    @Override
    public int getPartitionsCount() {
      return partitions_.size();
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    @Override
    public PartitionUpdate getPartitions(int index) {
      return partitions_.get(index);
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .PartitionUpdate partitions = 13;</code>
     */
    @Override
    public PartitionUpdateOrBuilder getPartitionsOrBuilder(
        int index) {
      return partitions_.get(index);
    }

    public static final int MAX_TIMESTAMP_FIELD_NUMBER = 14;
    private long maxTimestamp_;
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return Whether the maxTimestamp field is set.
     */
    @Override
    public boolean hasMaxTimestamp() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return The maxTimestamp.
     */
    @Override
    public long getMaxTimestamp() {
      return maxTimestamp_;
    }

    public static final int DYNAMIC_PARTITION_METADATA_FIELD_NUMBER = 15;
    private DynamicPartitionMetadata dynamicPartitionMetadata_;
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return Whether the dynamicPartitionMetadata field is set.
     */
    @Override
    public boolean hasDynamicPartitionMetadata() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return The dynamicPartitionMetadata.
     */
    @Override
    public DynamicPartitionMetadata getDynamicPartitionMetadata() {
      return dynamicPartitionMetadata_ == null ? DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     */
    @Override
    public DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder() {
      return dynamicPartitionMetadata_ == null ? DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
    }

    public static final int PARTIAL_UPDATE_FIELD_NUMBER = 16;
    private boolean partialUpdate_;
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return Whether the partialUpdate field is set.
     */
    @Override
    public boolean hasPartialUpdate() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return The partialUpdate.
     */
    @Override
    public boolean getPartialUpdate() {
      return partialUpdate_;
    }

    public static final int APEX_INFO_FIELD_NUMBER = 17;
    private java.util.List<ApexInfo> apexInfo_;
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    @Override
    public java.util.List<ApexInfo> getApexInfoList() {
      return apexInfo_;
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    @Override
    public java.util.List<? extends ApexInfoOrBuilder>
        getApexInfoOrBuilderList() {
      return apexInfo_;
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    @Override
    public int getApexInfoCount() {
      return apexInfo_.size();
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    @Override
    public ApexInfo getApexInfo(int index) {
      return apexInfo_.get(index);
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .ApexInfo apex_info = 17;</code>
     */
    @Override
    public ApexInfoOrBuilder getApexInfoOrBuilder(
        int index) {
      return apexInfo_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getInstallOperationsCount(); i++) {
        if (!getInstallOperations(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getKernelInstallOperationsCount(); i++) {
        if (!getKernelInstallOperations(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getPartitionsCount(); i++) {
        if (!getPartitions(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasDynamicPartitionMetadata()) {
        if (!getDynamicPartitionMetadata().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < installOperations_.size(); i++) {
        output.writeMessage(1, installOperations_.get(i));
      }
      for (int i = 0; i < kernelInstallOperations_.size(); i++) {
        output.writeMessage(2, kernelInstallOperations_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(3, blockSize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(4, signaturesOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(5, signaturesSize_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(6, getOldKernelInfo());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(7, getNewKernelInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(8, getOldRootfsInfo());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(9, getNewRootfsInfo());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(10, getOldImageInfo());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(11, getNewImageInfo());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeUInt32(12, minorVersion_);
      }
      for (int i = 0; i < partitions_.size(); i++) {
        output.writeMessage(13, partitions_.get(i));
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeInt64(14, maxTimestamp_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(15, getDynamicPartitionMetadata());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeBool(16, partialUpdate_);
      }
      for (int i = 0; i < apexInfo_.size(); i++) {
        output.writeMessage(17, apexInfo_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < installOperations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, installOperations_.get(i));
      }
      for (int i = 0; i < kernelInstallOperations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, kernelInstallOperations_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, blockSize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, signaturesOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, signaturesSize_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getOldKernelInfo());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getNewKernelInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getOldRootfsInfo());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getNewRootfsInfo());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getOldImageInfo());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getNewImageInfo());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, minorVersion_);
      }
      for (int i = 0; i < partitions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, partitions_.get(i));
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(14, maxTimestamp_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getDynamicPartitionMetadata());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, partialUpdate_);
      }
      for (int i = 0; i < apexInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, apexInfo_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof DeltaArchiveManifest)) {
        return super.equals(obj);
      }
      DeltaArchiveManifest other = (DeltaArchiveManifest) obj;

      if (!getInstallOperationsList()
          .equals(other.getInstallOperationsList())) return false;
      if (!getKernelInstallOperationsList()
          .equals(other.getKernelInstallOperationsList())) return false;
      if (hasBlockSize() != other.hasBlockSize()) return false;
      if (hasBlockSize()) {
        if (getBlockSize()
            != other.getBlockSize()) return false;
      }
      if (hasSignaturesOffset() != other.hasSignaturesOffset()) return false;
      if (hasSignaturesOffset()) {
        if (getSignaturesOffset()
            != other.getSignaturesOffset()) return false;
      }
      if (hasSignaturesSize() != other.hasSignaturesSize()) return false;
      if (hasSignaturesSize()) {
        if (getSignaturesSize()
            != other.getSignaturesSize()) return false;
      }
      if (hasOldKernelInfo() != other.hasOldKernelInfo()) return false;
      if (hasOldKernelInfo()) {
        if (!getOldKernelInfo()
            .equals(other.getOldKernelInfo())) return false;
      }
      if (hasNewKernelInfo() != other.hasNewKernelInfo()) return false;
      if (hasNewKernelInfo()) {
        if (!getNewKernelInfo()
            .equals(other.getNewKernelInfo())) return false;
      }
      if (hasOldRootfsInfo() != other.hasOldRootfsInfo()) return false;
      if (hasOldRootfsInfo()) {
        if (!getOldRootfsInfo()
            .equals(other.getOldRootfsInfo())) return false;
      }
      if (hasNewRootfsInfo() != other.hasNewRootfsInfo()) return false;
      if (hasNewRootfsInfo()) {
        if (!getNewRootfsInfo()
            .equals(other.getNewRootfsInfo())) return false;
      }
      if (hasOldImageInfo() != other.hasOldImageInfo()) return false;
      if (hasOldImageInfo()) {
        if (!getOldImageInfo()
            .equals(other.getOldImageInfo())) return false;
      }
      if (hasNewImageInfo() != other.hasNewImageInfo()) return false;
      if (hasNewImageInfo()) {
        if (!getNewImageInfo()
            .equals(other.getNewImageInfo())) return false;
      }
      if (hasMinorVersion() != other.hasMinorVersion()) return false;
      if (hasMinorVersion()) {
        if (getMinorVersion()
            != other.getMinorVersion()) return false;
      }
      if (!getPartitionsList()
          .equals(other.getPartitionsList())) return false;
      if (hasMaxTimestamp() != other.hasMaxTimestamp()) return false;
      if (hasMaxTimestamp()) {
        if (getMaxTimestamp()
            != other.getMaxTimestamp()) return false;
      }
      if (hasDynamicPartitionMetadata() != other.hasDynamicPartitionMetadata()) return false;
      if (hasDynamicPartitionMetadata()) {
        if (!getDynamicPartitionMetadata()
            .equals(other.getDynamicPartitionMetadata())) return false;
      }
      if (hasPartialUpdate() != other.hasPartialUpdate()) return false;
      if (hasPartialUpdate()) {
        if (getPartialUpdate()
            != other.getPartialUpdate()) return false;
      }
      if (!getApexInfoList()
          .equals(other.getApexInfoList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getInstallOperationsCount() > 0) {
        hash = (37 * hash) + INSTALL_OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getInstallOperationsList().hashCode();
      }
      if (getKernelInstallOperationsCount() > 0) {
        hash = (37 * hash) + KERNEL_INSTALL_OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getKernelInstallOperationsList().hashCode();
      }
      if (hasBlockSize()) {
        hash = (37 * hash) + BLOCK_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getBlockSize();
      }
      if (hasSignaturesOffset()) {
        hash = (37 * hash) + SIGNATURES_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSignaturesOffset());
      }
      if (hasSignaturesSize()) {
        hash = (37 * hash) + SIGNATURES_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSignaturesSize());
      }
      if (hasOldKernelInfo()) {
        hash = (37 * hash) + OLD_KERNEL_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldKernelInfo().hashCode();
      }
      if (hasNewKernelInfo()) {
        hash = (37 * hash) + NEW_KERNEL_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewKernelInfo().hashCode();
      }
      if (hasOldRootfsInfo()) {
        hash = (37 * hash) + OLD_ROOTFS_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldRootfsInfo().hashCode();
      }
      if (hasNewRootfsInfo()) {
        hash = (37 * hash) + NEW_ROOTFS_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewRootfsInfo().hashCode();
      }
      if (hasOldImageInfo()) {
        hash = (37 * hash) + OLD_IMAGE_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldImageInfo().hashCode();
      }
      if (hasNewImageInfo()) {
        hash = (37 * hash) + NEW_IMAGE_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewImageInfo().hashCode();
      }
      if (hasMinorVersion()) {
        hash = (37 * hash) + MINOR_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getMinorVersion();
      }
      if (getPartitionsCount() > 0) {
        hash = (37 * hash) + PARTITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionsList().hashCode();
      }
      if (hasMaxTimestamp()) {
        hash = (37 * hash) + MAX_TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getMaxTimestamp());
      }
      if (hasDynamicPartitionMetadata()) {
        hash = (37 * hash) + DYNAMIC_PARTITION_METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getDynamicPartitionMetadata().hashCode();
      }
      if (hasPartialUpdate()) {
        hash = (37 * hash) + PARTIAL_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPartialUpdate());
      }
      if (getApexInfoCount() > 0) {
        hash = (37 * hash) + APEX_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getApexInfoList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static DeltaArchiveManifest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DeltaArchiveManifest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DeltaArchiveManifest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DeltaArchiveManifest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DeltaArchiveManifest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static DeltaArchiveManifest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static DeltaArchiveManifest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static DeltaArchiveManifest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static DeltaArchiveManifest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static DeltaArchiveManifest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static DeltaArchiveManifest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static DeltaArchiveManifest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(DeltaArchiveManifest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code DeltaArchiveManifest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:DeltaArchiveManifest)
        DeltaArchiveManifestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
      }

      @Override
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                DeltaArchiveManifest.class, Builder.class);
      }

      // Construct using UpdateMetadata.DeltaArchiveManifest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getInstallOperationsFieldBuilder();
          getKernelInstallOperationsFieldBuilder();
          getOldKernelInfoFieldBuilder();
          getNewKernelInfoFieldBuilder();
          getOldRootfsInfoFieldBuilder();
          getNewRootfsInfoFieldBuilder();
          getOldImageInfoFieldBuilder();
          getNewImageInfoFieldBuilder();
          getPartitionsFieldBuilder();
          getDynamicPartitionMetadataFieldBuilder();
          getApexInfoFieldBuilder();
        }
      }
      @Override
      public Builder clear() {
        super.clear();
        if (installOperationsBuilder_ == null) {
          installOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          installOperationsBuilder_.clear();
        }
        if (kernelInstallOperationsBuilder_ == null) {
          kernelInstallOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          kernelInstallOperationsBuilder_.clear();
        }
        blockSize_ = 4096;
        bitField0_ = (bitField0_ & ~0x00000004);
        signaturesOffset_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000008);
        signaturesSize_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfo_ = null;
        } else {
          oldKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (newKernelInfoBuilder_ == null) {
          newKernelInfo_ = null;
        } else {
          newKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfo_ = null;
        } else {
          oldRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfo_ = null;
        } else {
          newRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        if (oldImageInfoBuilder_ == null) {
          oldImageInfo_ = null;
        } else {
          oldImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (newImageInfoBuilder_ == null) {
          newImageInfo_ = null;
        } else {
          newImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        minorVersion_ = 0;
        bitField0_ = (bitField0_ & ~0x00000800);
        if (partitionsBuilder_ == null) {
          partitions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
        } else {
          partitionsBuilder_.clear();
        }
        maxTimestamp_ = 0L;
        bitField0_ = (bitField0_ & ~0x00002000);
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadata_ = null;
        } else {
          dynamicPartitionMetadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        partialUpdate_ = false;
        bitField0_ = (bitField0_ & ~0x00008000);
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00010000);
        } else {
          apexInfoBuilder_.clear();
        }
        return this;
      }

      @Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
      }

      @Override
      public DeltaArchiveManifest getDefaultInstanceForType() {
        return DeltaArchiveManifest.getDefaultInstance();
      }

      @Override
      public DeltaArchiveManifest build() {
        DeltaArchiveManifest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public DeltaArchiveManifest buildPartial() {
        DeltaArchiveManifest result = new DeltaArchiveManifest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (installOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            installOperations_ = java.util.Collections.unmodifiableList(installOperations_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.installOperations_ = installOperations_;
        } else {
          result.installOperations_ = installOperationsBuilder_.build();
        }
        if (kernelInstallOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            kernelInstallOperations_ = java.util.Collections.unmodifiableList(kernelInstallOperations_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.kernelInstallOperations_ = kernelInstallOperations_;
        } else {
          result.kernelInstallOperations_ = kernelInstallOperationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.blockSize_ = blockSize_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.signaturesOffset_ = signaturesOffset_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.signaturesSize_ = signaturesSize_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          if (oldKernelInfoBuilder_ == null) {
            result.oldKernelInfo_ = oldKernelInfo_;
          } else {
            result.oldKernelInfo_ = oldKernelInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          if (newKernelInfoBuilder_ == null) {
            result.newKernelInfo_ = newKernelInfo_;
          } else {
            result.newKernelInfo_ = newKernelInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          if (oldRootfsInfoBuilder_ == null) {
            result.oldRootfsInfo_ = oldRootfsInfo_;
          } else {
            result.oldRootfsInfo_ = oldRootfsInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          if (newRootfsInfoBuilder_ == null) {
            result.newRootfsInfo_ = newRootfsInfo_;
          } else {
            result.newRootfsInfo_ = newRootfsInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          if (oldImageInfoBuilder_ == null) {
            result.oldImageInfo_ = oldImageInfo_;
          } else {
            result.oldImageInfo_ = oldImageInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          if (newImageInfoBuilder_ == null) {
            result.newImageInfo_ = newImageInfo_;
          } else {
            result.newImageInfo_ = newImageInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.minorVersion_ = minorVersion_;
          to_bitField0_ |= 0x00000200;
        }
        if (partitionsBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0)) {
            partitions_ = java.util.Collections.unmodifiableList(partitions_);
            bitField0_ = (bitField0_ & ~0x00001000);
          }
          result.partitions_ = partitions_;
        } else {
          result.partitions_ = partitionsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.maxTimestamp_ = maxTimestamp_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          if (dynamicPartitionMetadataBuilder_ == null) {
            result.dynamicPartitionMetadata_ = dynamicPartitionMetadata_;
          } else {
            result.dynamicPartitionMetadata_ = dynamicPartitionMetadataBuilder_.build();
          }
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.partialUpdate_ = partialUpdate_;
          to_bitField0_ |= 0x00001000;
        }
        if (apexInfoBuilder_ == null) {
          if (((bitField0_ & 0x00010000) != 0)) {
            apexInfo_ = java.util.Collections.unmodifiableList(apexInfo_);
            bitField0_ = (bitField0_ & ~0x00010000);
          }
          result.apexInfo_ = apexInfo_;
        } else {
          result.apexInfo_ = apexInfoBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @Override
      public Builder clone() {
        return super.clone();
      }
      @Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.setField(field, value);
      }
      @Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return super.addRepeatedField(field, value);
      }
      @Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof DeltaArchiveManifest) {
          return mergeFrom((DeltaArchiveManifest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(DeltaArchiveManifest other) {
        if (other == DeltaArchiveManifest.getDefaultInstance()) return this;
        if (installOperationsBuilder_ == null) {
          if (!other.installOperations_.isEmpty()) {
            if (installOperations_.isEmpty()) {
              installOperations_ = other.installOperations_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureInstallOperationsIsMutable();
              installOperations_.addAll(other.installOperations_);
            }
            onChanged();
          }
        } else {
          if (!other.installOperations_.isEmpty()) {
            if (installOperationsBuilder_.isEmpty()) {
              installOperationsBuilder_.dispose();
              installOperationsBuilder_ = null;
              installOperations_ = other.installOperations_;
              bitField0_ = (bitField0_ & ~0x00000001);
              installOperationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInstallOperationsFieldBuilder() : null;
            } else {
              installOperationsBuilder_.addAllMessages(other.installOperations_);
            }
          }
        }
        if (kernelInstallOperationsBuilder_ == null) {
          if (!other.kernelInstallOperations_.isEmpty()) {
            if (kernelInstallOperations_.isEmpty()) {
              kernelInstallOperations_ = other.kernelInstallOperations_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureKernelInstallOperationsIsMutable();
              kernelInstallOperations_.addAll(other.kernelInstallOperations_);
            }
            onChanged();
          }
        } else {
          if (!other.kernelInstallOperations_.isEmpty()) {
            if (kernelInstallOperationsBuilder_.isEmpty()) {
              kernelInstallOperationsBuilder_.dispose();
              kernelInstallOperationsBuilder_ = null;
              kernelInstallOperations_ = other.kernelInstallOperations_;
              bitField0_ = (bitField0_ & ~0x00000002);
              kernelInstallOperationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKernelInstallOperationsFieldBuilder() : null;
            } else {
              kernelInstallOperationsBuilder_.addAllMessages(other.kernelInstallOperations_);
            }
          }
        }
        if (other.hasBlockSize()) {
          setBlockSize(other.getBlockSize());
        }
        if (other.hasSignaturesOffset()) {
          setSignaturesOffset(other.getSignaturesOffset());
        }
        if (other.hasSignaturesSize()) {
          setSignaturesSize(other.getSignaturesSize());
        }
        if (other.hasOldKernelInfo()) {
          mergeOldKernelInfo(other.getOldKernelInfo());
        }
        if (other.hasNewKernelInfo()) {
          mergeNewKernelInfo(other.getNewKernelInfo());
        }
        if (other.hasOldRootfsInfo()) {
          mergeOldRootfsInfo(other.getOldRootfsInfo());
        }
        if (other.hasNewRootfsInfo()) {
          mergeNewRootfsInfo(other.getNewRootfsInfo());
        }
        if (other.hasOldImageInfo()) {
          mergeOldImageInfo(other.getOldImageInfo());
        }
        if (other.hasNewImageInfo()) {
          mergeNewImageInfo(other.getNewImageInfo());
        }
        if (other.hasMinorVersion()) {
          setMinorVersion(other.getMinorVersion());
        }
        if (partitionsBuilder_ == null) {
          if (!other.partitions_.isEmpty()) {
            if (partitions_.isEmpty()) {
              partitions_ = other.partitions_;
              bitField0_ = (bitField0_ & ~0x00001000);
            } else {
              ensurePartitionsIsMutable();
              partitions_.addAll(other.partitions_);
            }
            onChanged();
          }
        } else {
          if (!other.partitions_.isEmpty()) {
            if (partitionsBuilder_.isEmpty()) {
              partitionsBuilder_.dispose();
              partitionsBuilder_ = null;
              partitions_ = other.partitions_;
              bitField0_ = (bitField0_ & ~0x00001000);
              partitionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPartitionsFieldBuilder() : null;
            } else {
              partitionsBuilder_.addAllMessages(other.partitions_);
            }
          }
        }
        if (other.hasMaxTimestamp()) {
          setMaxTimestamp(other.getMaxTimestamp());
        }
        if (other.hasDynamicPartitionMetadata()) {
          mergeDynamicPartitionMetadata(other.getDynamicPartitionMetadata());
        }
        if (other.hasPartialUpdate()) {
          setPartialUpdate(other.getPartialUpdate());
        }
        if (apexInfoBuilder_ == null) {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfo_.isEmpty()) {
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00010000);
            } else {
              ensureApexInfoIsMutable();
              apexInfo_.addAll(other.apexInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfoBuilder_.isEmpty()) {
              apexInfoBuilder_.dispose();
              apexInfoBuilder_ = null;
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00010000);
              apexInfoBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getApexInfoFieldBuilder() : null;
            } else {
              apexInfoBuilder_.addAllMessages(other.apexInfo_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @Override
      public final boolean isInitialized() {
        for (int i = 0; i < getInstallOperationsCount(); i++) {
          if (!getInstallOperations(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getKernelInstallOperationsCount(); i++) {
          if (!getKernelInstallOperations(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getPartitionsCount(); i++) {
          if (!getPartitions(i).isInitialized()) {
            return false;
          }
        }
        if (hasDynamicPartitionMetadata()) {
          if (!getDynamicPartitionMetadata().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        DeltaArchiveManifest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (DeltaArchiveManifest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<InstallOperation> installOperations_ =
        java.util.Collections.emptyList();
      private void ensureInstallOperationsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          installOperations_ = new java.util.ArrayList<InstallOperation>(installOperations_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder> installOperationsBuilder_;

      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public java.util.List<InstallOperation> getInstallOperationsList() {
        if (installOperationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(installOperations_);
        } else {
          return installOperationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public int getInstallOperationsCount() {
        if (installOperationsBuilder_ == null) {
          return installOperations_.size();
        } else {
          return installOperationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation getInstallOperations(int index) {
        if (installOperationsBuilder_ == null) {
          return installOperations_.get(index);
        } else {
          return installOperationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder setInstallOperations(
          int index, InstallOperation value) {
        if (installOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInstallOperationsIsMutable();
          installOperations_.set(index, value);
          onChanged();
        } else {
          installOperationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder setInstallOperations(
          int index, InstallOperation.Builder builderForValue) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.set(index, builderForValue.build());
          onChanged();
        } else {
          installOperationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder addInstallOperations(InstallOperation value) {
        if (installOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInstallOperationsIsMutable();
          installOperations_.add(value);
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder addInstallOperations(
          int index, InstallOperation value) {
        if (installOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInstallOperationsIsMutable();
          installOperations_.add(index, value);
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder addInstallOperations(
          InstallOperation.Builder builderForValue) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.add(builderForValue.build());
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder addInstallOperations(
          int index, InstallOperation.Builder builderForValue) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.add(index, builderForValue.build());
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder addAllInstallOperations(
          Iterable<? extends InstallOperation> values) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, installOperations_);
          onChanged();
        } else {
          installOperationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder clearInstallOperations() {
        if (installOperationsBuilder_ == null) {
          installOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          installOperationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public Builder removeInstallOperations(int index) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.remove(index);
          onChanged();
        } else {
          installOperationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation.Builder getInstallOperationsBuilder(
          int index) {
        return getInstallOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public InstallOperationOrBuilder getInstallOperationsOrBuilder(
          int index) {
        if (installOperationsBuilder_ == null) {
          return installOperations_.get(index);  } else {
          return installOperationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public java.util.List<? extends InstallOperationOrBuilder>
           getInstallOperationsOrBuilderList() {
        if (installOperationsBuilder_ != null) {
          return installOperationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(installOperations_);
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation.Builder addInstallOperationsBuilder() {
        return getInstallOperationsFieldBuilder().addBuilder(
            InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation.Builder addInstallOperationsBuilder(
          int index) {
        return getInstallOperationsFieldBuilder().addBuilder(
            index, InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .InstallOperation install_operations = 1 [deprecated = true];</code>
       */
      @Deprecated public java.util.List<InstallOperation.Builder>
           getInstallOperationsBuilderList() {
        return getInstallOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder>
          getInstallOperationsFieldBuilder() {
        if (installOperationsBuilder_ == null) {
          installOperationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder>(
                  installOperations_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          installOperations_ = null;
        }
        return installOperationsBuilder_;
      }

      private java.util.List<InstallOperation> kernelInstallOperations_ =
        java.util.Collections.emptyList();
      private void ensureKernelInstallOperationsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          kernelInstallOperations_ = new java.util.ArrayList<InstallOperation>(kernelInstallOperations_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder> kernelInstallOperationsBuilder_;

      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public java.util.List<InstallOperation> getKernelInstallOperationsList() {
        if (kernelInstallOperationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(kernelInstallOperations_);
        } else {
          return kernelInstallOperationsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public int getKernelInstallOperationsCount() {
        if (kernelInstallOperationsBuilder_ == null) {
          return kernelInstallOperations_.size();
        } else {
          return kernelInstallOperationsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation getKernelInstallOperations(int index) {
        if (kernelInstallOperationsBuilder_ == null) {
          return kernelInstallOperations_.get(index);
        } else {
          return kernelInstallOperationsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder setKernelInstallOperations(
          int index, InstallOperation value) {
        if (kernelInstallOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.set(index, value);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder setKernelInstallOperations(
          int index, InstallOperation.Builder builderForValue) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.set(index, builderForValue.build());
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder addKernelInstallOperations(InstallOperation value) {
        if (kernelInstallOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(value);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder addKernelInstallOperations(
          int index, InstallOperation value) {
        if (kernelInstallOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(index, value);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder addKernelInstallOperations(
          InstallOperation.Builder builderForValue) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(builderForValue.build());
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder addKernelInstallOperations(
          int index, InstallOperation.Builder builderForValue) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(index, builderForValue.build());
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder addAllKernelInstallOperations(
          Iterable<? extends InstallOperation> values) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, kernelInstallOperations_);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder clearKernelInstallOperations() {
        if (kernelInstallOperationsBuilder_ == null) {
          kernelInstallOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public Builder removeKernelInstallOperations(int index) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.remove(index);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation.Builder getKernelInstallOperationsBuilder(
          int index) {
        return getKernelInstallOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public InstallOperationOrBuilder getKernelInstallOperationsOrBuilder(
          int index) {
        if (kernelInstallOperationsBuilder_ == null) {
          return kernelInstallOperations_.get(index);  } else {
          return kernelInstallOperationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public java.util.List<? extends InstallOperationOrBuilder>
           getKernelInstallOperationsOrBuilderList() {
        if (kernelInstallOperationsBuilder_ != null) {
          return kernelInstallOperationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(kernelInstallOperations_);
        }
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation.Builder addKernelInstallOperationsBuilder() {
        return getKernelInstallOperationsFieldBuilder().addBuilder(
            InstallOperation.getDefaultInstance());
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public InstallOperation.Builder addKernelInstallOperationsBuilder(
          int index) {
        return getKernelInstallOperationsFieldBuilder().addBuilder(
            index, InstallOperation.getDefaultInstance());
      }
      /**
       * <code>repeated .InstallOperation kernel_install_operations = 2 [deprecated = true];</code>
       */
      @Deprecated public java.util.List<InstallOperation.Builder>
           getKernelInstallOperationsBuilderList() {
        return getKernelInstallOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder>
          getKernelInstallOperationsFieldBuilder() {
        if (kernelInstallOperationsBuilder_ == null) {
          kernelInstallOperationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              InstallOperation, InstallOperation.Builder, InstallOperationOrBuilder>(
                  kernelInstallOperations_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          kernelInstallOperations_ = null;
        }
        return kernelInstallOperationsBuilder_;
      }

      private int blockSize_ = 4096;
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return Whether the blockSize field is set.
       */
      @Override
      public boolean hasBlockSize() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return The blockSize.
       */
      @Override
      public int getBlockSize() {
        return blockSize_;
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @param value The blockSize to set.
       * @return This builder for chaining.
       */
      public Builder setBlockSize(int value) {
        bitField0_ |= 0x00000004;
        blockSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockSize() {
        bitField0_ = (bitField0_ & ~0x00000004);
        blockSize_ = 4096;
        onChanged();
        return this;
      }

      private long signaturesOffset_ ;
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return Whether the signaturesOffset field is set.
       */
      @Override
      public boolean hasSignaturesOffset() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return The signaturesOffset.
       */
      @Override
      public long getSignaturesOffset() {
        return signaturesOffset_;
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @param value The signaturesOffset to set.
       * @return This builder for chaining.
       */
      public Builder setSignaturesOffset(long value) {
        bitField0_ |= 0x00000008;
        signaturesOffset_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignaturesOffset() {
        bitField0_ = (bitField0_ & ~0x00000008);
        signaturesOffset_ = 0L;
        onChanged();
        return this;
      }

      private long signaturesSize_ ;
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return Whether the signaturesSize field is set.
       */
      @Override
      public boolean hasSignaturesSize() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return The signaturesSize.
       */
      @Override
      public long getSignaturesSize() {
        return signaturesSize_;
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @param value The signaturesSize to set.
       * @return This builder for chaining.
       */
      public Builder setSignaturesSize(long value) {
        bitField0_ |= 0x00000010;
        signaturesSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignaturesSize() {
        bitField0_ = (bitField0_ & ~0x00000010);
        signaturesSize_ = 0L;
        onChanged();
        return this;
      }

      private PartitionInfo oldKernelInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder> oldKernelInfoBuilder_;
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       * @return Whether the oldKernelInfo field is set.
       */
      @Deprecated public boolean hasOldKernelInfo() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       * @return The oldKernelInfo.
       */
      @Deprecated public PartitionInfo getOldKernelInfo() {
        if (oldKernelInfoBuilder_ == null) {
          return oldKernelInfo_ == null ? PartitionInfo.getDefaultInstance() : oldKernelInfo_;
        } else {
          return oldKernelInfoBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       */
      @Deprecated public Builder setOldKernelInfo(PartitionInfo value) {
        if (oldKernelInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldKernelInfo_ = value;
          onChanged();
        } else {
          oldKernelInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       */
      @Deprecated public Builder setOldKernelInfo(
          PartitionInfo.Builder builderForValue) {
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldKernelInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       */
      @Deprecated public Builder mergeOldKernelInfo(PartitionInfo value) {
        if (oldKernelInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
              oldKernelInfo_ != null &&
              oldKernelInfo_ != PartitionInfo.getDefaultInstance()) {
            oldKernelInfo_ =
              PartitionInfo.newBuilder(oldKernelInfo_).mergeFrom(value).buildPartial();
          } else {
            oldKernelInfo_ = value;
          }
          onChanged();
        } else {
          oldKernelInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       */
      @Deprecated public Builder clearOldKernelInfo() {
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfo_ = null;
          onChanged();
        } else {
          oldKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfo.Builder getOldKernelInfoBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getOldKernelInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfoOrBuilder getOldKernelInfoOrBuilder() {
        if (oldKernelInfoBuilder_ != null) {
          return oldKernelInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldKernelInfo_ == null ?
              PartitionInfo.getDefaultInstance() : oldKernelInfo_;
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .PartitionInfo old_kernel_info = 6 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>
          getOldKernelInfoFieldBuilder() {
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>(
                  getOldKernelInfo(),
                  getParentForChildren(),
                  isClean());
          oldKernelInfo_ = null;
        }
        return oldKernelInfoBuilder_;
      }

      private PartitionInfo newKernelInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder> newKernelInfoBuilder_;
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       * @return Whether the newKernelInfo field is set.
       */
      @Deprecated public boolean hasNewKernelInfo() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       * @return The newKernelInfo.
       */
      @Deprecated public PartitionInfo getNewKernelInfo() {
        if (newKernelInfoBuilder_ == null) {
          return newKernelInfo_ == null ? PartitionInfo.getDefaultInstance() : newKernelInfo_;
        } else {
          return newKernelInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       */
      @Deprecated public Builder setNewKernelInfo(PartitionInfo value) {
        if (newKernelInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newKernelInfo_ = value;
          onChanged();
        } else {
          newKernelInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       */
      @Deprecated public Builder setNewKernelInfo(
          PartitionInfo.Builder builderForValue) {
        if (newKernelInfoBuilder_ == null) {
          newKernelInfo_ = builderForValue.build();
          onChanged();
        } else {
          newKernelInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       */
      @Deprecated public Builder mergeNewKernelInfo(PartitionInfo value) {
        if (newKernelInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
              newKernelInfo_ != null &&
              newKernelInfo_ != PartitionInfo.getDefaultInstance()) {
            newKernelInfo_ =
              PartitionInfo.newBuilder(newKernelInfo_).mergeFrom(value).buildPartial();
          } else {
            newKernelInfo_ = value;
          }
          onChanged();
        } else {
          newKernelInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       */
      @Deprecated public Builder clearNewKernelInfo() {
        if (newKernelInfoBuilder_ == null) {
          newKernelInfo_ = null;
          onChanged();
        } else {
          newKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfo.Builder getNewKernelInfoBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getNewKernelInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfoOrBuilder getNewKernelInfoOrBuilder() {
        if (newKernelInfoBuilder_ != null) {
          return newKernelInfoBuilder_.getMessageOrBuilder();
        } else {
          return newKernelInfo_ == null ?
              PartitionInfo.getDefaultInstance() : newKernelInfo_;
        }
      }
      /**
       * <code>optional .PartitionInfo new_kernel_info = 7 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>
          getNewKernelInfoFieldBuilder() {
        if (newKernelInfoBuilder_ == null) {
          newKernelInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>(
                  getNewKernelInfo(),
                  getParentForChildren(),
                  isClean());
          newKernelInfo_ = null;
        }
        return newKernelInfoBuilder_;
      }

      private PartitionInfo oldRootfsInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder> oldRootfsInfoBuilder_;
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       * @return Whether the oldRootfsInfo field is set.
       */
      @Deprecated public boolean hasOldRootfsInfo() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       * @return The oldRootfsInfo.
       */
      @Deprecated public PartitionInfo getOldRootfsInfo() {
        if (oldRootfsInfoBuilder_ == null) {
          return oldRootfsInfo_ == null ? PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
        } else {
          return oldRootfsInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       */
      @Deprecated public Builder setOldRootfsInfo(PartitionInfo value) {
        if (oldRootfsInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldRootfsInfo_ = value;
          onChanged();
        } else {
          oldRootfsInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       */
      @Deprecated public Builder setOldRootfsInfo(
          PartitionInfo.Builder builderForValue) {
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldRootfsInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       */
      @Deprecated public Builder mergeOldRootfsInfo(PartitionInfo value) {
        if (oldRootfsInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
              oldRootfsInfo_ != null &&
              oldRootfsInfo_ != PartitionInfo.getDefaultInstance()) {
            oldRootfsInfo_ =
              PartitionInfo.newBuilder(oldRootfsInfo_).mergeFrom(value).buildPartial();
          } else {
            oldRootfsInfo_ = value;
          }
          onChanged();
        } else {
          oldRootfsInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       */
      @Deprecated public Builder clearOldRootfsInfo() {
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfo_ = null;
          onChanged();
        } else {
          oldRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfo.Builder getOldRootfsInfoBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getOldRootfsInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfoOrBuilder getOldRootfsInfoOrBuilder() {
        if (oldRootfsInfoBuilder_ != null) {
          return oldRootfsInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldRootfsInfo_ == null ?
              PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
        }
      }
      /**
       * <code>optional .PartitionInfo old_rootfs_info = 8 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>
          getOldRootfsInfoFieldBuilder() {
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>(
                  getOldRootfsInfo(),
                  getParentForChildren(),
                  isClean());
          oldRootfsInfo_ = null;
        }
        return oldRootfsInfoBuilder_;
      }

      private PartitionInfo newRootfsInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder> newRootfsInfoBuilder_;
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       * @return Whether the newRootfsInfo field is set.
       */
      @Deprecated public boolean hasNewRootfsInfo() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       * @return The newRootfsInfo.
       */
      @Deprecated public PartitionInfo getNewRootfsInfo() {
        if (newRootfsInfoBuilder_ == null) {
          return newRootfsInfo_ == null ? PartitionInfo.getDefaultInstance() : newRootfsInfo_;
        } else {
          return newRootfsInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       */
      @Deprecated public Builder setNewRootfsInfo(PartitionInfo value) {
        if (newRootfsInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newRootfsInfo_ = value;
          onChanged();
        } else {
          newRootfsInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       */
      @Deprecated public Builder setNewRootfsInfo(
          PartitionInfo.Builder builderForValue) {
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfo_ = builderForValue.build();
          onChanged();
        } else {
          newRootfsInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       */
      @Deprecated public Builder mergeNewRootfsInfo(PartitionInfo value) {
        if (newRootfsInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
              newRootfsInfo_ != null &&
              newRootfsInfo_ != PartitionInfo.getDefaultInstance()) {
            newRootfsInfo_ =
              PartitionInfo.newBuilder(newRootfsInfo_).mergeFrom(value).buildPartial();
          } else {
            newRootfsInfo_ = value;
          }
          onChanged();
        } else {
          newRootfsInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       */
      @Deprecated public Builder clearNewRootfsInfo() {
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfo_ = null;
          onChanged();
        } else {
          newRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfo.Builder getNewRootfsInfoBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getNewRootfsInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       */
      @Deprecated public PartitionInfoOrBuilder getNewRootfsInfoOrBuilder() {
        if (newRootfsInfoBuilder_ != null) {
          return newRootfsInfoBuilder_.getMessageOrBuilder();
        } else {
          return newRootfsInfo_ == null ?
              PartitionInfo.getDefaultInstance() : newRootfsInfo_;
        }
      }
      /**
       * <code>optional .PartitionInfo new_rootfs_info = 9 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>
          getNewRootfsInfoFieldBuilder() {
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              PartitionInfo, PartitionInfo.Builder, PartitionInfoOrBuilder>(
                  getNewRootfsInfo(),
                  getParentForChildren(),
                  isClean());
          newRootfsInfo_ = null;
        }
        return newRootfsInfoBuilder_;
      }

      private ImageInfo oldImageInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ImageInfo, ImageInfo.Builder, ImageInfoOrBuilder> oldImageInfoBuilder_;
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       * @return Whether the oldImageInfo field is set.
       */
      @Deprecated public boolean hasOldImageInfo() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       * @return The oldImageInfo.
       */
      @Deprecated public ImageInfo getOldImageInfo() {
        if (oldImageInfoBuilder_ == null) {
          return oldImageInfo_ == null ? ImageInfo.getDefaultInstance() : oldImageInfo_;
        } else {
          return oldImageInfoBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       */
      @Deprecated public Builder setOldImageInfo(ImageInfo value) {
        if (oldImageInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldImageInfo_ = value;
          onChanged();
        } else {
          oldImageInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       */
      @Deprecated public Builder setOldImageInfo(
          ImageInfo.Builder builderForValue) {
        if (oldImageInfoBuilder_ == null) {
          oldImageInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldImageInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       */
      @Deprecated public Builder mergeOldImageInfo(ImageInfo value) {
        if (oldImageInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
              oldImageInfo_ != null &&
              oldImageInfo_ != ImageInfo.getDefaultInstance()) {
            oldImageInfo_ =
              ImageInfo.newBuilder(oldImageInfo_).mergeFrom(value).buildPartial();
          } else {
            oldImageInfo_ = value;
          }
          onChanged();
        } else {
          oldImageInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       */
      @Deprecated public Builder clearOldImageInfo() {
        if (oldImageInfoBuilder_ == null) {
          oldImageInfo_ = null;
          onChanged();
        } else {
          oldImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       */
      @Deprecated public ImageInfo.Builder getOldImageInfoBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getOldImageInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       */
      @Deprecated public ImageInfoOrBuilder getOldImageInfoOrBuilder() {
        if (oldImageInfoBuilder_ != null) {
          return oldImageInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldImageInfo_ == null ?
              ImageInfo.getDefaultInstance() : oldImageInfo_;
        }
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .ImageInfo old_image_info = 10 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ImageInfo, ImageInfo.Builder, ImageInfoOrBuilder>
          getOldImageInfoFieldBuilder() {
        if (oldImageInfoBuilder_ == null) {
          oldImageInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ImageInfo, ImageInfo.Builder, ImageInfoOrBuilder>(
                  getOldImageInfo(),
                  getParentForChildren(),
                  isClean());
          oldImageInfo_ = null;
        }
        return oldImageInfoBuilder_;
      }

      private ImageInfo newImageInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          ImageInfo, ImageInfo.Builder, ImageInfoOrBuilder> newImageInfoBuilder_;
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       * @return Whether the newImageInfo field is set.
       */
      @Deprecated public boolean hasNewImageInfo() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       * @return The newImageInfo.
       */
      @Deprecated public ImageInfo getNewImageInfo() {
        if (newImageInfoBuilder_ == null) {
          return newImageInfo_ == null ? ImageInfo.getDefaultInstance() : newImageInfo_;
        } else {
          return newImageInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       */
      @Deprecated public Builder setNewImageInfo(ImageInfo value) {
        if (newImageInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newImageInfo_ = value;
          onChanged();
        } else {
          newImageInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       */
      @Deprecated public Builder setNewImageInfo(
          ImageInfo.Builder builderForValue) {
        if (newImageInfoBuilder_ == null) {
          newImageInfo_ = builderForValue.build();
          onChanged();
        } else {
          newImageInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       */
      @Deprecated public Builder mergeNewImageInfo(ImageInfo value) {
        if (newImageInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
              newImageInfo_ != null &&
              newImageInfo_ != ImageInfo.getDefaultInstance()) {
            newImageInfo_ =
              ImageInfo.newBuilder(newImageInfo_).mergeFrom(value).buildPartial();
          } else {
            newImageInfo_ = value;
          }
          onChanged();
        } else {
          newImageInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       */
      @Deprecated public Builder clearNewImageInfo() {
        if (newImageInfoBuilder_ == null) {
          newImageInfo_ = null;
          onChanged();
        } else {
          newImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       */
      @Deprecated public ImageInfo.Builder getNewImageInfoBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getNewImageInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       */
      @Deprecated public ImageInfoOrBuilder getNewImageInfoOrBuilder() {
        if (newImageInfoBuilder_ != null) {
          return newImageInfoBuilder_.getMessageOrBuilder();
        } else {
          return newImageInfo_ == null ?
              ImageInfo.getDefaultInstance() : newImageInfo_;
        }
      }
      /**
       * <code>optional .ImageInfo new_image_info = 11 [deprecated = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          ImageInfo, ImageInfo.Builder, ImageInfoOrBuilder>
          getNewImageInfoFieldBuilder() {
        if (newImageInfoBuilder_ == null) {
          newImageInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              ImageInfo, ImageInfo.Builder, ImageInfoOrBuilder>(
                  getNewImageInfo(),
                  getParentForChildren(),
                  isClean());
          newImageInfo_ = null;
        }
        return newImageInfoBuilder_;
      }

      private int minorVersion_ ;
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return Whether the minorVersion field is set.
       */
      @Override
      public boolean hasMinorVersion() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return The minorVersion.
       */
      @Override
      public int getMinorVersion() {
        return minorVersion_;
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @param value The minorVersion to set.
       * @return This builder for chaining.
       */
      public Builder setMinorVersion(int value) {
        bitField0_ |= 0x00000800;
        minorVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinorVersion() {
        bitField0_ = (bitField0_ & ~0x00000800);
        minorVersion_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<PartitionUpdate> partitions_ =
        java.util.Collections.emptyList();
      private void ensurePartitionsIsMutable() {
        if (!((bitField0_ & 0x00001000) != 0)) {
          partitions_ = new java.util.ArrayList<PartitionUpdate>(partitions_);
          bitField0_ |= 0x00001000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          PartitionUpdate, PartitionUpdate.Builder, PartitionUpdateOrBuilder> partitionsBuilder_;

      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<PartitionUpdate> getPartitionsList() {
        if (partitionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(partitions_);
        } else {
          return partitionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public int getPartitionsCount() {
        if (partitionsBuilder_ == null) {
          return partitions_.size();
        } else {
          return partitionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public PartitionUpdate getPartitions(int index) {
        if (partitionsBuilder_ == null) {
          return partitions_.get(index);
        } else {
          return partitionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder setPartitions(
          int index, PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.set(index, value);
          onChanged();
        } else {
          partitionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder setPartitions(
          int index, PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.set(index, builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.add(value);
          onChanged();
        } else {
          partitionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          int index, PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.add(index, value);
          onChanged();
        } else {
          partitionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.add(builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          int index, PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.add(index, builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder addAllPartitions(
          Iterable<? extends PartitionUpdate> values) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, partitions_);
          onChanged();
        } else {
          partitionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder clearPartitions() {
        if (partitionsBuilder_ == null) {
          partitions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
          onChanged();
        } else {
          partitionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public Builder removePartitions(int index) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.remove(index);
          onChanged();
        } else {
          partitionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public PartitionUpdate.Builder getPartitionsBuilder(
          int index) {
        return getPartitionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public PartitionUpdateOrBuilder getPartitionsOrBuilder(
          int index) {
        if (partitionsBuilder_ == null) {
          return partitions_.get(index);  } else {
          return partitionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<? extends PartitionUpdateOrBuilder>
           getPartitionsOrBuilderList() {
        if (partitionsBuilder_ != null) {
          return partitionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(partitions_);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public PartitionUpdate.Builder addPartitionsBuilder() {
        return getPartitionsFieldBuilder().addBuilder(
            PartitionUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public PartitionUpdate.Builder addPartitionsBuilder(
          int index) {
        return getPartitionsFieldBuilder().addBuilder(
            index, PartitionUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<PartitionUpdate.Builder>
           getPartitionsBuilderList() {
        return getPartitionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          PartitionUpdate, PartitionUpdate.Builder, PartitionUpdateOrBuilder>
          getPartitionsFieldBuilder() {
        if (partitionsBuilder_ == null) {
          partitionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              PartitionUpdate, PartitionUpdate.Builder, PartitionUpdateOrBuilder>(
                  partitions_,
                  ((bitField0_ & 0x00001000) != 0),
                  getParentForChildren(),
                  isClean());
          partitions_ = null;
        }
        return partitionsBuilder_;
      }

      private long maxTimestamp_ ;
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return Whether the maxTimestamp field is set.
       */
      @Override
      public boolean hasMaxTimestamp() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return The maxTimestamp.
       */
      @Override
      public long getMaxTimestamp() {
        return maxTimestamp_;
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @param value The maxTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setMaxTimestamp(long value) {
        bitField0_ |= 0x00002000;
        maxTimestamp_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxTimestamp() {
        bitField0_ = (bitField0_ & ~0x00002000);
        maxTimestamp_ = 0L;
        onChanged();
        return this;
      }

      private DynamicPartitionMetadata dynamicPartitionMetadata_;
      private com.google.protobuf.SingleFieldBuilderV3<
          DynamicPartitionMetadata, DynamicPartitionMetadata.Builder, DynamicPartitionMetadataOrBuilder> dynamicPartitionMetadataBuilder_;
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       * @return Whether the dynamicPartitionMetadata field is set.
       */
      public boolean hasDynamicPartitionMetadata() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       * @return The dynamicPartitionMetadata.
       */
      public DynamicPartitionMetadata getDynamicPartitionMetadata() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          return dynamicPartitionMetadata_ == null ? DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
        } else {
          return dynamicPartitionMetadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder setDynamicPartitionMetadata(DynamicPartitionMetadata value) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          dynamicPartitionMetadata_ = value;
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder setDynamicPartitionMetadata(
          DynamicPartitionMetadata.Builder builderForValue) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadata_ = builderForValue.build();
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder mergeDynamicPartitionMetadata(DynamicPartitionMetadata value) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0) &&
              dynamicPartitionMetadata_ != null &&
              dynamicPartitionMetadata_ != DynamicPartitionMetadata.getDefaultInstance()) {
            dynamicPartitionMetadata_ =
              DynamicPartitionMetadata.newBuilder(dynamicPartitionMetadata_).mergeFrom(value).buildPartial();
          } else {
            dynamicPartitionMetadata_ = value;
          }
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder clearDynamicPartitionMetadata() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadata_ = null;
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public DynamicPartitionMetadata.Builder getDynamicPartitionMetadataBuilder() {
        bitField0_ |= 0x00004000;
        onChanged();
        return getDynamicPartitionMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder() {
        if (dynamicPartitionMetadataBuilder_ != null) {
          return dynamicPartitionMetadataBuilder_.getMessageOrBuilder();
        } else {
          return dynamicPartitionMetadata_ == null ?
              DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
        }
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          DynamicPartitionMetadata, DynamicPartitionMetadata.Builder, DynamicPartitionMetadataOrBuilder>
          getDynamicPartitionMetadataFieldBuilder() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              DynamicPartitionMetadata, DynamicPartitionMetadata.Builder, DynamicPartitionMetadataOrBuilder>(
                  getDynamicPartitionMetadata(),
                  getParentForChildren(),
                  isClean());
          dynamicPartitionMetadata_ = null;
        }
        return dynamicPartitionMetadataBuilder_;
      }

      private boolean partialUpdate_ ;
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return Whether the partialUpdate field is set.
       */
      @Override
      public boolean hasPartialUpdate() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return The partialUpdate.
       */
      @Override
      public boolean getPartialUpdate() {
        return partialUpdate_;
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @param value The partialUpdate to set.
       * @return This builder for chaining.
       */
      public Builder setPartialUpdate(boolean value) {
        bitField0_ |= 0x00008000;
        partialUpdate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartialUpdate() {
        bitField0_ = (bitField0_ & ~0x00008000);
        partialUpdate_ = false;
        onChanged();
        return this;
      }

      private java.util.List<ApexInfo> apexInfo_ =
        java.util.Collections.emptyList();
      private void ensureApexInfoIsMutable() {
        if (!((bitField0_ & 0x00010000) != 0)) {
          apexInfo_ = new java.util.ArrayList<ApexInfo>(apexInfo_);
          bitField0_ |= 0x00010000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ApexInfo, ApexInfo.Builder, ApexInfoOrBuilder> apexInfoBuilder_;

      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public java.util.List<ApexInfo> getApexInfoList() {
        if (apexInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(apexInfo_);
        } else {
          return apexInfoBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public int getApexInfoCount() {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.size();
        } else {
          return apexInfoBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public ApexInfo getApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);
        } else {
          return apexInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder setApexInfo(
          int index, ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.set(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder setApexInfo(
          int index, ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(
          int index, ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(
          ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(
          int index, ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder addAllApexInfo(
          Iterable<? extends ApexInfo> values) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, apexInfo_);
          onChanged();
        } else {
          apexInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder clearApexInfo() {
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00010000);
          onChanged();
        } else {
          apexInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public Builder removeApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.remove(index);
          onChanged();
        } else {
          apexInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public ApexInfo.Builder getApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public ApexInfoOrBuilder getApexInfoOrBuilder(
          int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);  } else {
          return apexInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public java.util.List<? extends ApexInfoOrBuilder>
           getApexInfoOrBuilderList() {
        if (apexInfoBuilder_ != null) {
          return apexInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(apexInfo_);
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public ApexInfo.Builder addApexInfoBuilder() {
        return getApexInfoFieldBuilder().addBuilder(
            ApexInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public ApexInfo.Builder addApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().addBuilder(
            index, ApexInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .ApexInfo apex_info = 17;</code>
       */
      public java.util.List<ApexInfo.Builder>
           getApexInfoBuilderList() {
        return getApexInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ApexInfo, ApexInfo.Builder, ApexInfoOrBuilder>
          getApexInfoFieldBuilder() {
        if (apexInfoBuilder_ == null) {
          apexInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ApexInfo, ApexInfo.Builder, ApexInfoOrBuilder>(
                  apexInfo_,
                  ((bitField0_ & 0x00010000) != 0),
                  getParentForChildren(),
                  isClean());
          apexInfo_ = null;
        }
        return apexInfoBuilder_;
      }
      @Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:DeltaArchiveManifest)
    }

    // @@protoc_insertion_point(class_scope:DeltaArchiveManifest)
    private static final DeltaArchiveManifest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new DeltaArchiveManifest();
    }

    public static DeltaArchiveManifest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @Deprecated public static final com.google.protobuf.Parser<DeltaArchiveManifest>
        PARSER = new com.google.protobuf.AbstractParser<DeltaArchiveManifest>() {
      @Override
      public DeltaArchiveManifest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeltaArchiveManifest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeltaArchiveManifest> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<DeltaArchiveManifest> getParserForType() {
      return PARSER;
    }

    @Override
    public DeltaArchiveManifest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Extent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Extent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Signatures_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Signatures_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_PartitionInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_ImageInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_InstallOperation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_ApexInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_ApexMetadata_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    String[] descriptorData = {
      "\n\025update_metadata.proto\022\026chromeos_update" +
      "_engine\"1\n\006Extent\022\023\n\013start_block\030\001 \001(\004\022\022" +
      "\n\nnum_blocks\030\002 \001(\004\"\237\001\n\nSignatures\022@\n\nsig" +
      "natures\030\001 \003(\0132,.S" +
      "ignatures.Signature\032O\n\tSignature\022\023\n\007vers" +
      "ion\030\001 \001(\rB\002\030\001\022\014\n\004data\030\002 \001(\014\022\037\n\027unpadded_" +
      "signature_size\030\003 \001(\007\"+\n\rPartitionInfo\022\014\n" +
      "\004size\030\001 \001(\004\022\014\n\004hash\030\002 \001(\014\"\217\001\n\tImageInfo\022" +
      "\021\n\005board\030\001 \001(\tB\002\030\001\022\017\n\003key\030\002 \001(\tB\002\030\001\022\023\n\007c" +
      "hannel\030\003 \001(\tB\002\030\001\022\023\n\007version\030\004 \001(\tB\002\030\001\022\031\n" +
      "\rbuild_channel\030\005 \001(\tB\002\030\001\022\031\n\rbuild_versio" +
      "n\030\006 \001(\tB\002\030\001\"\374\003\n\020InstallOperation\022;\n\004type" +
      "\030\001 \002(\0162-.InstallO" +
      "peration.Type\022\023\n\013data_offset\030\002 \001(\004\022\023\n\013da" +
      "ta_length\030\003 \001(\004\0223\n\013src_extents\030\004 \003(\0132\036.c" +
      "hromeos_update_engine.Extent\022\022\n\nsrc_leng" +
      "th\030\005 \001(\004\0223\n\013dst_extents\030\006 \003(\0132\036.chromeos" +
      "_update_engine.Extent\022\022\n\ndst_length\030\007 \001(" +
      "\004\022\030\n\020data_sha256_hash\030\010 \001(\014\022\027\n\017src_sha25" +
      "6_hash\030\t \001(\014\"\273\001\n\004Type\022\013\n\007REPLACE\020\000\022\016\n\nRE" +
      "PLACE_BZ\020\001\022\014\n\004MOVE\020\002\032\002\010\001\022\016\n\006BSDIFF\020\003\032\002\010\001" +
      "\022\017\n\013SOURCE_COPY\020\004\022\021\n\rSOURCE_BSDIFF\020\005\022\016\n\n" +
      "REPLACE_XZ\020\010\022\010\n\004ZERO\020\006\022\013\n\007DISCARD\020\007\022\021\n\rB" +
      "ROTLI_BSDIFF\020\n\022\014\n\010PUFFDIFF\020\t\022\014\n\010ZUCCHINI" +
      "\020\013\"\201\002\n\021CowMergeOperation\022<\n\004type\030\001 \001(\0162." +
      ".CowMergeOperatio" +
      "n.Type\0222\n\nsrc_extent\030\002 \001(\0132\036.chromeos_up" +
      "date_engine.Extent\0222\n\ndst_extent\030\003 \001(\0132\036" +
      ".Extent\022\022\n\nsrc_of" +
      "fset\030\004 \001(\r\"2\n\004Type\022\014\n\010COW_COPY\020\000\022\013\n\007COW_" +
      "XOR\020\001\022\017\n\013COW_REPLACE\020\002\"\310\006\n\017PartitionUpda" +
      "te\022\026\n\016partition_name\030\001 \002(\t\022\027\n\017run_postin" +
      "stall\030\002 \001(\010\022\030\n\020postinstall_path\030\003 \001(\t\022\027\n" +
      "\017filesystem_type\030\004 \001(\t\022M\n\027new_partition_" +
      "signature\030\005 \003(\0132,.chromeos_update_engine" +
      ".Signatures.Signature\022A\n\022old_partition_i" +
      "nfo\030\006 \001(\0132%.Parti" +
      "tionInfo\022A\n\022new_partition_info\030\007 \001(\0132%.c" +
      "hromeos_update_engine.PartitionInfo\022<\n\no" +
      "perations\030\010 \003(\0132(.chromeos_update_engine" +
      ".InstallOperation\022\034\n\024postinstall_optiona" +
      "l\030\t \001(\010\022=\n\025hash_tree_data_extent\030\n \001(\0132\036" +
      ".Extent\0228\n\020hash_t" +
      "ree_extent\030\013 \001(\0132\036.chromeos_update_engin" +
      "e.Extent\022\033\n\023hash_tree_algorithm\030\014 \001(\t\022\026\n" +
      "\016hash_tree_salt\030\r \001(\014\0227\n\017fec_data_extent" +
      "\030\016 \001(\0132\036.Extent\0222" +
      "\n\nfec_extent\030\017 \001(\0132\036.chromeos_update_eng" +
      "ine.Extent\022\024\n\tfec_roots\030\020 \001(\r:\0012\022\017\n\007vers" +
      "ion\030\021 \001(\t\022C\n\020merge_operations\030\022 \003(\0132).ch" +
      "romeos_update_engine.CowMergeOperation\022\031" +
      "\n\021estimate_cow_size\030\023 \001(\004\"L\n\025DynamicPart" +
      "itionGroup\022\014\n\004name\030\001 \002(\t\022\014\n\004size\030\002 \001(\004\022\027" +
      "\n\017partition_names\030\003 \003(\t\"\276\001\n\030DynamicParti" +
      "tionMetadata\022=\n\006groups\030\001 \003(\0132-.chromeos_" +
      "update_engine.DynamicPartitionGroup\022\030\n\020s" +
      "napshot_enabled\030\002 \001(\010\022\024\n\014vabc_enabled\030\003 " +
      "\001(\010\022\036\n\026vabc_compression_param\030\004 \001(\t\022\023\n\013c" +
      "ow_version\030\005 \001(\r\"c\n\010ApexInfo\022\024\n\014package_" +
      "name\030\001 \001(\t\022\017\n\007version\030\002 \001(\003\022\025\n\ris_compre" +
      "ssed\030\003 \001(\010\022\031\n\021decompressed_size\030\004 \001(\003\"C\n" +
      "\014ApexMetadata\0223\n\tapex_info\030\001 \003(\0132 .chrom" +
      "eos_update_engine.ApexInfo\"\236\007\n\024DeltaArch" +
      "iveManifest\022H\n\022install_operations\030\001 \003(\0132" +
      "(.InstallOperatio" +
      "nB\002\030\001\022O\n\031kernel_install_operations\030\002 \003(\013" +
      "2(.InstallOperati" +
      "onB\002\030\001\022\030\n\nblock_size\030\003 \001(\r:\0044096\022\031\n\021sign" +
      "atures_offset\030\004 \001(\004\022\027\n\017signatures_size\030\005" +
      " \001(\004\022B\n\017old_kernel_info\030\006 \001(\0132%.chromeos" +
      "_update_engine.PartitionInfoB\002\030\001\022B\n\017new_" +
      "kernel_info\030\007 \001(\0132%.chromeos_update_engi" +
      "ne.PartitionInfoB\002\030\001\022B\n\017old_rootfs_info\030" +
      "\010 \001(\0132%.Partition" +
      "InfoB\002\030\001\022B\n\017new_rootfs_info\030\t \001(\0132%.chro" +
      "meos_update_engine.PartitionInfoB\002\030\001\022=\n\016" +
      "old_image_info\030\n \001(\0132!.chromeos_update_e" +
      "ngine.ImageInfoB\002\030\001\022=\n\016new_image_info\030\013 " +
      "\001(\0132!.ImageInfoB\002" +
      "\030\001\022\030\n\rminor_version\030\014 \001(\r:\0010\022;\n\npartitio" +
      "ns\030\r \003(\0132\'.Partit" +
      "ionUpdate\022\025\n\rmax_timestamp\030\016 \001(\003\022T\n\032dyna" +
      "mic_partition_metadata\030\017 \001(\01320.chromeos_" +
      "update_engine.DynamicPartitionMetadata\022\026" +
      "\n\016partial_update\030\020 \001(\010\0223\n\tapex_info\030\021 \003(" +
      "\0132 .ApexInfoB\002H\003"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_chromeos_update_engine_Extent_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_chromeos_update_engine_Extent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Extent_descriptor,
        new String[] { "StartBlock", "NumBlocks", });
    internal_static_chromeos_update_engine_Signatures_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_chromeos_update_engine_Signatures_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Signatures_descriptor,
        new String[] { "Signatures", });
    internal_static_chromeos_update_engine_Signatures_Signature_descriptor =
      internal_static_chromeos_update_engine_Signatures_descriptor.getNestedTypes().get(0);
    internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Signatures_Signature_descriptor,
        new String[] { "Version", "Data", "UnpaddedSignatureSize", });
    internal_static_chromeos_update_engine_PartitionInfo_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_PartitionInfo_descriptor,
        new String[] { "Size", "Hash", });
    internal_static_chromeos_update_engine_ImageInfo_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_ImageInfo_descriptor,
        new String[] { "Board", "Key", "Channel", "Version", "BuildChannel", "BuildVersion", });
    internal_static_chromeos_update_engine_InstallOperation_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_InstallOperation_descriptor,
        new String[] { "Type", "DataOffset", "DataLength", "SrcExtents", "SrcLength", "DstExtents", "DstLength", "DataSha256Hash", "SrcSha256Hash", });
    internal_static_chromeos_update_engine_CowMergeOperation_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_CowMergeOperation_descriptor,
        new String[] { "Type", "SrcExtent", "DstExtent", "SrcOffset", });
    internal_static_chromeos_update_engine_PartitionUpdate_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_PartitionUpdate_descriptor,
        new String[] { "PartitionName", "RunPostinstall", "PostinstallPath", "FilesystemType", "NewPartitionSignature", "OldPartitionInfo", "NewPartitionInfo", "Operations", "PostinstallOptional", "HashTreeDataExtent", "HashTreeExtent", "HashTreeAlgorithm", "HashTreeSalt", "FecDataExtent", "FecExtent", "FecRoots", "Version", "MergeOperations", "EstimateCowSize", });
    internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor,
        new String[] { "Name", "Size", "PartitionNames", });
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor,
        new String[] { "Groups", "SnapshotEnabled", "VabcEnabled", "VabcCompressionParam", "CowVersion", });
    internal_static_chromeos_update_engine_ApexInfo_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_ApexInfo_descriptor,
        new String[] { "PackageName", "Version", "IsCompressed", "DecompressedSize", });
    internal_static_chromeos_update_engine_ApexMetadata_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_ApexMetadata_descriptor,
        new String[] { "ApexInfo", });
    internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor,
        new String[] { "InstallOperations", "KernelInstallOperations", "BlockSize", "SignaturesOffset", "SignaturesSize", "OldKernelInfo", "NewKernelInfo", "OldRootfsInfo", "NewRootfsInfo", "OldImageInfo", "NewImageInfo", "MinorVersion", "Partitions", "MaxTimestamp", "DynamicPartitionMetadata", "PartialUpdate", "ApexInfo", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
